
//  Created by Евгений Никитин on 12.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

final class InitializationSet {
	static func getQuestions() -> [Question] {
		return [
			Question(question: [
                "Что включает в себя процесс инициализации экземпляра?",
                "Во время инициализации экземпляра класса или структуры происходит это",
                "Что происходит в момент инициализации экземпляров класса, структуры или перечисления?"
            ],
					 image: "",
					 optionA: "Установка начальных значений",
					 optionB: "Освобождение памяти",
					 optionC: "Создание свойств хранения",
					 optionD: "Создание самого экземпляра",
					 id: 377274344,
                     helpText: """
                     Установка начальных значений. Инициализация - подготовительный процесс экземпляра класса, структуры или перечисления для дальнейшего использования.
                     
                     Этот процесс включает в себя установку начальных значений для каждого свойства хранения этого экземпляра и проведение любых настроек или инициализации, которые нужны до того, как экземпляр будет использоваться.
                     """),
			
			Question(question: [
                "Инициализаторы в Swift возвращают значение?",
                "Возвращают ли инициализаторы в Swift значение?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "",
					 optionD: "",
					 id: 698737550,
					 helpText: "Нет. Вы реализуете инициализацию, определяя инициализаторы, которые схожи со специальными методами, которые вызываются для создания экземпляра определенного типа. В отличии от инициализаторов в Objective-C, инициализаторы в Swift не возвращают значения."),
			
			Question(question: [
                "Какая основная роль инициализаторов?",
                "Основная роль инициализаторов",
                "У инициализаторов есть основная задача, какая?"
            ],
					 image: "",
					 optionA: "Корректная инициализация",
					 optionB: "Освобождение памяти",
					 optionC: "Создание свойств хранения",
					 optionD: "Освобождение экземпляра класса",
					 id: 578752942,
					 helpText: "Корректная инициализация. Основная роль инициализаторов - убедиться в том, что новый экземпляр типа правильно инициализирован до того, как будет использован в первый раз."),
			
			Question(question: [
                "Могут ли экземпляры структуры иметь деинициализатор?",
                "Может ли экземпляр перечисления иметь деинициализатор?",
                "Экземпляр класса не может иметь деинициализатор, так ли это?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "",
					 optionD: "",
					 id: 300853649,
					 helpText: "Нет. Экземпляры классовых типов так же могут реализовывать деинициализаторы, которые проводят любую чистку прямо перед тем, как экземпляр класса будет освобожден."),
			
			Question(question: [
                "Обязаны ли классы и структуры устанавливать начальные значения у всех свойств хранения, во время создания экземпляра?",
                "Классы и структуры должны устанавливать начальные значения у всех свойств хранения во время создания класса или структуры, так ли это?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "Только экземплярам класса",
					 optionD: "Только экземплярам структуры",
					 id: 641870416,
					 helpText: "Да. Классы и структуры должны устанавливать начальные значения у всех свойств хранения во время создания класса или структуры. Свойства хранения не могут быть оставлены в неопределённом состоянии."),
			
			Question(question: [
                "Можем ли мы присвоить значение по умолчанию для свойства хранения, как часть определения свойства?",
                "Вы можете установить значение по умолчанию, как часть определения свойства хранения, так ли это?",
                "Можем ли мы установить значение по умолчанию для свойства хранения, вместо использования инициализатора?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 524090133,
					 helpText: "Да. Вы можете установить начальное значение свойства внутри инициализатора или присвоить ему значение по умолчанию, как часть определения свойства."),
			
			Question(question: [
                "Если мы устанавливаем значение по умолчанию для свойства хранения, наблюдатель вызывается?",
                "Когда мы устанавливаем исходное значение для свойства хранения в инициализаторе, будет вызываться наблюдатель?",
                "Когда мы присваиваем значение по умолчанию или устанавливаем исходное значение в инициализаторе, значение устанавливается не напрямую, и мы вызываем наблюдателя свойства. Так ли это?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "",
					 optionD: "",
					 id: 918922624,
					 helpText: "Нет. Когда вы присваиваете значение по умолчанию свойству хранения или устанавливаете исходное значение в инициализаторе, то значение устанавливается напрямую, без вызова наблюдателей."),
			
			Question(question: [
                "Каким ключевым словом вызывается инициализатор экземпляра?",
                "Этим ключевым словом можно вызвать инициализатор экземпляра класса",
                "Мы можем вызвать инициализатор класса с помощью этого ключевого слова"
            ],
					 image: "",
					 optionA: "init",
					 optionB: "deinit",
					 optionC: "func",
					 optionD: "var",
					 id: 978390324,
					 helpText: "init. Инициализаторы вызываются для создания нового экземпляра конкретного типа. В самой простой своей форме инициализатор работает как метод экземпляра без параметров, написанный с помощью ключевого слова init."),
			
			Question(question: [
                "Предпочтительнее использовать исходные значения для свойств, если эти значения повторяются, или использовать инициализатор?",
                "Что предпочтительнее, при повторяющихся значениях свойств, использовать инициализатор или исходные значения для свойств хранения?"
            ],
					 image: "",
					 optionA: "Исходные значения",
					 optionB: "Инициализатор",
					 optionC: "Без разницы",
					 optionD: "",
					 id: 887560277,
                     helpText: """
                     Исходные значения. Если свойство каждый раз берет одно и то же исходное значение, то лучше указать это значение, в качестве значения по умолчанию, чем каждый раз устанавливать его в инициализаторе.
                     
                     Конечный результат такой же, но значение по умолчанию связывает инициализацию свойства ближе к своему объявлению. Так делают, чтобы оставить инициализаторы в более чистой и краткой форме, и это позволяет вам вывести тип свойства из его значения по умолчанию.
                     """),
			
			Question(question: [
                "Являются ли данные структуры равнозначными?",
                "Эти структуры эквивалентны?"
            ],
					 image: "Initialization11",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 793515943,
					 helpText: "Да. Вы можете написать структуру FahrenheitSecond в более простой форме, указав значение по умолчанию для свойства temperature, в месте его объявления в инициализаторе."),
			
			Question(question: [
                "Могут ли инициализаторы иметь входящие параметры?",
                "Вы можете показать параметры инициализации как часть определения инициализатора, так ли это?",
                "Параметры инициализатора имеют те же возможности и синтаксис, как и параметры функции или метода?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 109473185,
					 helpText: "Да. Вы можете указать параметры инициализации как часть определения инициализатора, для определения типов и имен значений, которые настраивают процесс инициализации. Параметры инициализации имеют те же возможности и синтаксис как и параметры функции или метода."),
			
			Question(question: [
                "Может ли класс иметь два пользовательских инициализатора?",
                "Может ли структура иметь три пользовательских инициализатора?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 365748367,
					 helpText: "Да. Классы и структуры могут иметь необходимое количество пользовательских инициализаторов. Главное, чтобы ваши инициализаторы имели разные внешние имена."),
			
			Question(question: [
                "Параметры инициализации могут иметь как внешнее, так и локальное имя одновременно. Так ли это?",
                "Параметры инициализации могут иметь локальные имена и внешние имена, это так?",
                "У параметров инициализации, как и у параметров функций или методов, есть локальные и внешние имена, это так?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "Только внешнее имя",
					 optionD: "Только локальное имя",
					 id: 376932435,
					 helpText: "Да. Как и в случае с параметрами функций или методов, параметры инициализации могут иметь локальные имена для использования внутри тела инициализатора и внешние для использования при вызове инициализатора."),
			
			Question(question: [
                "Может ли инициализатор иметь свое имя?",
                "Имеет ли инициализатор имя как методы или функции?",
                "Есть ли у инициализаторов имена до круглых скобок?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "",
					 optionD: "",
					 id: 732153211,
					 helpText: "Нет. Инициализаторы не имеют своего имени до круглых скобок, как это имеют методы или функции. Поэтому имена и типы параметров инициализатора играют важную роль в определении того, какой инициализатор и где может быть использован."),
			
			Question(question: [
                "Если вы не укажите внешнее имя для параметра инициализатора, что произойдет?"
            ],
					 image: "",
					 optionA: "Предоставится автоматически",
					 optionB: "Внешнего имения не будет",
					 optionC: "Столкнемся с ошибкой",
					 optionD: "",
					 id: 126029946,
					 helpText: "Предоставится автоматически. Swift предоставляет автоматические внешние имена для каждого параметра, если вы, конечно, не укажите своё внешнее имя."),
			
			Question(question: [
                "Если у параметра инициализатора определено внешнее имя, можем ли мы вызвать его, не указывая это имя?",
                "Можем ли мы вызвать инициализатор без внешних имен параметров, если они определены?"
            ],
					 image: "",
					 optionA: "Получим ошибку компиляции",
					 optionB: "Да, можем",
					 optionC: "На наше усмотрение",
					 optionD: "",
					 id: 993579324,
					 helpText: "Получим ошибку компиляции. Обратите внимание, что невозможно вызвать инициализатор без использования внешних имен. Внешние имена обязательно должны быть использованы в инициализаторе, если они определены, если пропустить их, то выскочит ошибка компиляции."),
			
			Question(question: [
                "Если при вызове инициализатора вы не хотите использовать внешние имена для параметров инициализации, какой символ мы должны поставить до локального имени?",
                "Какой символ мы можем поставить до локального имена параметра инициализатора, чтобы при его вызове нам не пришлось указывать внешнее имя?"
            ],
					 image: "",
					 optionA: "Нижнее подчеркивание (_)",
					 optionB: "Двоеточие (:)",
					 optionC: "Тире (-)",
					 optionD: "Амперсанд (&)",
					 id: 568402200,
					 helpText: "Нижнее подчеркивание (_). Если вы не хотите использовать внешние имена для параметров инициализации, напишите подчеркивание (_) вместо явного указания внешнего имени для этого параметра, чтобы переопределить поведение по умолчанию."),
			
			Question(question: [
                "Если ваш пользовательский тип имеет свойство, которое логически имеет “отсутствие значения, какой тип для этого свойства необходимо использовать?"
            ],
					 image: "",
					 optionA: "Опциональный",
					 optionB: "nil",
					 optionC: "Int",
					 optionD: "String",
					 id: 105409420,
                     helpText: """
                     Опциональный. Если ваш пользовательский тип имеет свойство, которое логически имеет “отсутствие значения”, возможно потому, что его значение не может быть установлено во время инициализации или потому, что ему разрешается иметь “отсутствие значения” в какой-либо точке кода, то такое свойство нужно объявить с опциональным типом.
                     
                     Свойства опционального типа автоматически инициализируются со значением nil, указывая на то, что значение стремится иметь значение “пока что отсутствие значение” на этапе инициализации.
                     """),
			
			Question(question: [
                "Можем ли мы изменять постоянное свойство хранения, после того, как мы присвоили значение в процессе инициализации?",
                "Когда во время инициализации мы присвоили значение постоянному свойству хранения, можем ли мы его дальше изменять?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "",
					 optionD: "",
					 id: 913328182,
					 helpText: "Нет. Вы можете присвоить значения постоянных (когда свойство константа) свойств в любой точке вашего процесса инициализации. Как только для свойства константы присваивается значение, оно не может быть далее изменено."),
			
			Question(question: [
                "В какой момент мы можем изменять постоянное свойство хранения у экземпляра класса?",
                "Когда вы можете изменить постоянное свойство хранения у экземпляра?"
            ],
					 image: "",
					 optionA: "Во время инициализации",
					 optionB: "Никогда",
					 optionC: "В любой момент",
					 optionD: "В подклассе",
					 id: 562236588,
					 helpText: "Во время инициализации. В экземплярах класса постоянное свойство может быть изменено только во время инициализации класса, в котором оно представлено. Оно не может быть изменено подклассом."),
			
			Question(question: [
                "Может ли подкласс изменять проинициализированное постоянное свойство хренения суперкласса?",
                "Мы можем изменить постоянно свойство хранения суперкласса в экземпляре подкласса, так ли это?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "",
					 optionD: "",
					 id: 293217157,
					 helpText: "Нет. В экземплярах класса постоянное свойство может быть изменено только во время инициализации класса, в котором оно представлено. Оно не может быть изменено подклассом."),
			
			Question(question: [
                "Если у всех свойств структуры есть исходное значение, и нет инициализатора, чем мы можем воспользоваться, чтобы создать новый экземпляр?",
                "У базового класса, который имеет значение по умолчанию для всех его свойств и не имеет ни одного инициализатора, есть это, и с помощью этого можно создавать новые экземпляры"
            ],
					 image: "",
					 optionA: "Дефолтный инициализатор",
					 optionB: "Стартовый инициализатор",
					 optionC: "Деинициализатор",
					 optionD: "Стартер",
					 id: 332265455,
                     helpText: """
                     Дефолтный инициализатор. Swift предоставляет дефолтный инициализатор для любой структуры или базового класса, который имеет значение по умолчанию для всех его свойств и не имеет ни одного инициализатора.
                     
                     Дефолтный инициализатор просто создает новый экземпляр со всеми его свойствами с уже присвоенными значениями по умолчанию.
                     """),
			
			Question(question: [
                "Что мы получим после компиляции?",
                "Какой результат мы получим после запуска данного кода?"
            ],
					 image: "Initialization24",
					 optionA: "Экземпляр ShoppingListItem",
					 optionB: "Ошибку компиляции",
					 optionC: "Ошибку инициализации",
					 optionD: "",
					 id: 348528050,
                     helpText: """
                     Экземпляр ShoppingListItem. Так как все свойства класса ShoppingListItem имеют значения по умолчанию и так как этот класс не имеет суперкласса, то ShoppingListItem автоматически получает реализацию дефолтного инициализатора, который создает новый экземпляр со всеми свойствами с уже присвоенными значениями по умолчанию.
                     
                     Свойство name - свойство опционального типа String, значит значение по умолчанию .
                     
                     В примере используется дефолтный инициализатор для класса ShoppingListItem для создания нового экземпляра. Синтаксис дефолтного инициализатора в нашем случае выглядит как ShoppingListItem(), что присваивается переменной item.
                     """),
			
			Question(question: [
                "Этот инициализатор предоставляет сокращенный способ инициализировать свойства нового экземпляра структуры"
            ],
					 image: "",
					 optionA: "Почленный (Memberwise)",
					 optionB: "Дефолтный (Default)",
					 optionC: "Деинициализатор (deinit)",
					 optionD: "Назначенный (Designated)",
					 id: 757192982,
					 helpText: "Почленный (Memberwise). Почленный инициализатор (Memberwise init) - это сокращенный способ инициализировать свойства нового экземпляра структуры. Начальные значения для свойств нового экземпляра могут быть переданы в почленный инициализатор по имени."),
			
			Question(question: [
                "Могут ли инициализаторы вызывать другие инициализаторы?",
                "Могут ли инициализаторы вызывать другие инициализаторы для инициализации части экземпляра?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 913735050,
					 helpText: "Да. Инициализаторы могут вызывать другие инициализаторы для инициализации части экземпляра. Этот процесс называется как делегирование инициализатора. Он позволяет избегать дублирования кода в разных инициализаторах."),
			
			Question(question: [
                "Для типов значения и ссылочных типов существуют разные правила для делегирования инициализатора, так ли это?",
                "Наследование у классов провоцирует другое поведение при делегировании инициализатора, так ли это?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 665600487,
                     helpText: """
                     Да. Правила того, как работает делегирование инициализатора и для каких форм делегирования это возможно, для типов значений и ссылочных типов разные.
                     
                     Типы значений (структуры и перечисления) не поддерживают наследование, так что их процесс делегирования инициализатора сравнительно прост, потому что они только могут делегировать другому инициализатору то, что предоставляют сами.
                     
                     Классы, однако, могут наследовать от других классов. Это значит, что у классов есть дополнительная ответственность за проверку наличия корректных значений у каждого унаследованного свойства хранения класса.
                     """),
			
			Question(question: [
                "Если мы определили пользовательский инициализатор для типа значений, будем ли мы иметь доступ к дефолтному или почленному инициализатору?",
                "Будем ли мы иметь доступ к дефолтному инициализатору, если мы определили пользовательский инициализатор для типа значений (структуры или перечисления)?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "",
					 optionD: "",
					 id: 333150794,
                     helpText: """
                     Нет. Обратите внимание, что если вы определите пользовательский инициализатор для типов значений, то вы больше не будете иметь доступа к дефолтному инициализатору (или почленному инициализатору, если это структура) для этого типа.
                     
                     Такое ограничение предотвращает ситуацию, в которой настройка важного дополнения в более сложном инициализаторе может быть пропущена при случайном использовании автоматического инициализатора.
                     """),
			
			Question(question: [
                "Где мы должны написать пользовательский инициализатор, чтобы иметь возможность продолжать пользоваться дефолтным инициализатором или почленным инициализатором типа значения?",
                "Чтобы иметь возможность пользоваться дефолтным инициализатором типа значения, но так же сделать свой пользовательский инициализатор, мы должны написать его там"
            ],
					 image: "",
					 optionA: "В расширении типа",
					 optionB: "Внутри структуры",
					 optionC: "В дефолтном инициализаторе",
					 optionD: "Не имеет значения",
					 id: 982296845,
                     helpText: """
                     В расширении типа. Если вы хотите, чтобы ваш пользовательский тип значения имел возможность быть инициализированным дефолтным инициализатором или почленным инициализатором, или вашим пользовательским инициализатором, то вам нужно написать свой пользовательский инициализатор в расширении вашего типа, чем как часть реализации типа значения.
                     """),
			
			Question(question: [
                "Как записываются назначенные инициализаторы (Designated init) классов?",
                "Назначенные инициализаторы (Designated init) для классов записываются именно так"
            ],
					 image: "",
					 optionA: "init() { }",
					 optionB: "required init() { }",
					 optionC: "convenience init() { }",
					 optionD: "override init() { }",
					 id: 469709367,
                     helpText: """
                     init() { }. Назначенные инициализаторы (Designated init) для классов записываются точно так же как и простые инициализаторы для типов значений. Назначенные инициализаторы в основном инициализаторы класса.
                     
                     Они предназначены для того, чтобы полностью инициализировать все свойства представленные классом и чтобы вызвать соответствующий инициализатор суперкласса для продолжения процесса инициализации цепочки наследований суперклассов.
                     """),
			
			Question(question: [
                "Как записываются вспомогательные инициализаторы классов?",
                "Вспомогательные инициализаторы для классов записываются именно так"
            ],
					 image: "",
					 optionA: "convenience init() { }",
					 optionB: "required init() { }",
					 optionC: "init() { }",
					 optionD: "override init() { }",
					 id: 905287111,
                     helpText: """
                     convenience init() { }. Вспомогательные инициализаторы (Convenience init) пишутся как назначенные (Designated init), но только дополнительно используется ключевое слово convenience, которое располагается до слова init и разделяется пробелом.
                     
                     Вспомогательные инициализаторы являются вторичными, поддерживающими инициализаторами для класса. Вы можете определить вспомогательный инициализатор для вызова назначенного инициализатора из того же класса, что и вспомогательный инициализатор с некоторыми параметрами назначенного инициализатора с установленными начальными значениями.
                     """),
			
			Question(question: [
                "Обязаны ли мы обеспечивать вспомогательные инициализаторы (Convenience init), если класс не нуждается в них?",
                "Если наш класс не нуждается во вспомогательных инициализаторах (Convenience init), обязаны ли мы их обеспечить?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "",
					 optionD: "",
					 id: 731762124,
					 helpText: "Нет. Вы не обязаны обеспечивать вспомогательные инициализаторы (Convenience init), если ваш класс не нуждается в них. Создавайте вспомогательный инициализатор всякий раз, когда это является наиболее рациональным путем общей инициализации и может сэкономить время и сделать саму инициализацию класса более чистой и краткой."),
			
			Question(question: [
                "Как делегируют назначенные инициализаторы (Designated init)?",
                "Назначенные инициализаторы (Designated init) делегируют таким образом"
            ],
					 image: "",
					 optionA: "Наверх (в суперкласс)",
					 optionB: "По своему уровню",
					 optionC: "Внутри своего класса",
					 optionD: "",
					 id: 701109430,
                     helpText: """
                     Наверх (в суперкласс).
                     
                     Правило 1: Назначенный инициализатор (Designated init) должен вызывать назначенный инициализатор из суперкласса.
                     
                     Правило 2: Вспомогательный инициализатор (Convenience init) должен вызывать другой инициализатор из того же класса.
                     
                     Правило 3: Вспомогательный инициализатор (Convenience init) в конечном счете должен вызывать назначенный инициализатор.
                     
                     Вот как можно просто это запомнить: Назначенные инициализаторы должны делегировать наверх, вспомогательные инициализаторы должны делегировать по своему уровню (классу).
                     """),
			
			Question(question: [
                "Сколько вспомогательных инициализаторов имеет суперкласс?",
                "Сколько назначенных инициализаторов имеет подкласс?"
            ],
					 image: "Initialization34",
					 optionA: "Два",
					 optionB: "Один",
					 optionC: "Нисколько",
					 optionD: "",
					 id: 301695592,
                     helpText: """
                     Два. Здесь, в суперклассе есть один назначенный инициализатор (Designated init) и два вспомогательных инициализатора (Convenience init). Один вспомогательный инициализатор вызывает другой вспомогательный инициализатор, который в свою очередь вызывает единственный назначенный инициализатор.
                     
                     Подкласс на этом рисунке содержит два назначенных инициализатора и один вспомогательный инициализатор. Вспомогательный инициализатор должен вызвать одного из двух назначенных инициализаторов, потому что он может вызвать другой инициализатор того же класса.
                     """),
			
			Question(question: [
                "Каким является процесс инициализации в Swift?",
                "Процесс инициализации в Swift является таким"
            ],
					 image: "",
					 optionA: "Двухфазным",
					 optionB: "Трехфазным",
					 optionC: "Моментальным",
					 optionD: "Ограниченным",
					 id: 578377486,
                     helpText: """
                     Двухфазным. Инициализация класса в Swift является двухфазным процессом. На первой фазе каждое свойство получает начальное значение от класса, в котором оно представлено.
                     
                     Как только первоначальные значения для свойств хранения были определены, начинается вторая фаза, и каждому классу предоставляется возможность изменить свои свойства еще до того как будет считаться, что созданный экземпляр можно использовать.
                     
                     Использование двухфазного процесса инициализации делает инициализацию безопасной, в то же время обеспечивая полную гибкость классов в классовой иерархии. Двухфазная инициализация предотвращает доступ к значениям свойств до того, как они будут инициализированы и не допускает случайную установку значения свойства другим инициализатором.
                     """),
			
			Question(question: [
                "Сколько проверок Swift проводит, чтобы проверить, что наша двухфазная инициализация прошла без ошибок?",
                "Swift проводит именно столько проверок, чтобы удостовериться, что двухфазная инициализация прошла без ошибок",
                "Чтобы убедиться, что двухфазная инициализация прошла без ошибок, Swift проводит такое количество проверок (каждый раз)"
            ],
					 image: "",
					 optionA: "Четыре",
					 optionB: "Три",
					 optionC: "Две",
					 optionD: "Одну",
					 id: 501960153,
                     helpText: """
                     Четыре. Компилятор Swift проводит четыре полезные проверки безопасности для подтверждения того, что ваша двухфазная инициализация прошла без ошибок.
                     
                     1: Назначенный инициализатор (Designated init) убеждается, что все свойства его класса инициализированы до того, как он делегирует их наверх в суперкласс.
                     2: Он же должен делегировать суперклассу инициализатор до присваивания значений унаследованным свойствам.
                     3: Вспомогательный инициализатор (Convenience init) делегирует другому инициализатору до того, как будут присвоены значения любым свойствам.
                     4: Инициализатор не может вызывать методы экземпляра и читать значения любого свойства экземпляра, пока не будет закончена 1 фаза инициализации.
                     """),
			
			Question(question: [
                "Согласно первой проверке безопасности двухфазной инициализации в Swift, память считается полностью инициализированной только для этих объектов"
            ],
					 image: "",
					 optionA: "Полностью инициализированных",
					 optionB: "Любых",
					 optionC: "Частично инициализированных",
					 optionD: "С назначенными инициализаторами",
					 id: 291285691,
                     helpText: """
                     Полностью инициализированных. Память для объекта считается полностью инициализированной только для полностью инициализированного объекта, где все значения хранимых свойств известны.
                     
                     Для того чтобы удовлетворить этому правилу, назначенный инициализатор (Designated init) должен убедиться, что все его собственные свойства инициализированы до того, как будут переданы вверх по цепочке.
                     """),
			
			Question(question: [
                "Если назначенный инициализатор (Designated init) не делегирует суперклассу инициализатор до присваивания значений унаследованным свойствам, что произойдет со значениями, которые он присвоил?"
            ],
					 image: "",
					 optionA: "Перепишутся суперклассом",
					 optionB: "Сбросятся на nil",
					 optionC: "Ничего не произойдет",
					 optionD: "",
					 id: 595402365,
                     helpText: """
                     Перепишутся суперклассом. Назначенный инициализатор (Designated init) должен делегировать суперклассу инициализатор до присваивания значений унаследованным свойствам.
                     
                     Если этого сделано не будет, то новое значение, которое присвоит назначенный инициализатор будет переписано суперклассом, как часть инициализации суперкласса.
                     """),
			
			Question(question: [
                "Если вспомогательный инициализатор (Convenience init) не делегировал другому инициализатору до того, как были присвоены значения любым свойствам, что произойдет со значениями свойств?"
            ],
					 image: "",
					 optionA: "Перезапишутся назначенным",
					 optionB: "Перепишутся суперклассом",
					 optionC: "Сбросятся на nil",
					 optionD: "Столкнемся с ошибкой",
					 id: 653118106,
                     helpText: """
                     Перезапишутся назначенным. Вспомогательный инициализатор (Convenience init) должен делегировать другому инициализатору до того, как будут присвоены значения любым свойствам (включая свойства определенные тем же классом).
                     
                     Если этого сделано не будет, то новое значение, которое присваивает вспомогательный инициализатор, будет перезаписано его собственным назначенным инициализатором (Designated init) класса.
                     """),
			
			Question(question: [
                "К какой фазе инициализации относятся эти пункты: \"назначенный или вспомогательный инициализатор вызывается в классе, выделяется память под новый экземпляр этого класса, но она еще не инициализирована\"?",
                "К какой фазе инициализации относятся эти пункты: \"Назначенный инициализатор для этого класса подтверждает, что все свойства, представленные этим классом, имеют значения\"?"
            ],
					 image: "",
					 optionA: "К первой фазе",
					 optionB: "Ко второй фазе",
					 optionC: "К третьей фазе",
					 optionD: "Ни к какой",
					 id: 163900124,
                     helpText: """
                     К первой фазе. Назначенный (Designated init) или вспомогательный (Convenience init) инициализатор вызывается, память под экземпляр выделяется, но она еще не инициализирована.
                     
                     Инициализатор подтверждает, что все свойства имеют значения. Память под эти свойства теперь инициализирована. Он передает инициализатору суперкласса, что пора проводить те же действия, только для его собственных свойств. Так продолжается по цепочке до самого верхнего суперкласса.
                     
                     Когда верхушка этой цепочки достигнута - только тогда считается, что память для этого экземпляра полностью инициализирована. На этом первая фаза кончается.
                     """),
			
			Question(question: [
                "К какой фазе инициализации относится этот пункт: \"Двигаясь вниз по цепочке, каждый назначенный инициализатор в этой цепочке имеет такую возможность, как настраивать экземпляр\"?",
                "К какой фазе инициализации относится этот пункт: \"Теперь инициализаторы получают доступ к self и могут изменять свои свойства, создавать экземпляры и вызывать методы и т.д.\"?"
            ],
					 image: "",
					 optionA: "Ко второй фазе",
					 optionB: "К первой фазе",
					 optionC: "К третьей фазе",
					 optionD: "Ни к какой",
					 id: 174250220,
                     helpText: """
                     Ко второй фазе. Фаза вторая: Двигаясь вниз по цепочке, каждый назначенный инициализатор (Designated init) в этой цепочке имеет такую возможность, как настраивать экземпляр.
                     
                     Теперь инициализаторы получают доступ к self и могут изменять свои свойства, создавать экземпляры и вызывать методы и т.д. И наконец, каждый вспомогательный инициализатор (Convenience init) в цепочки имеет возможность настраивать экземпляр и работать с self.
                     """),
			
			Question(question: [
                "Какая фаза инициализации для гипотетического подкласса и суперкласса на изображении?",
                "На изображении эта фаза инициализации для гипотетического подкласса и суперкласса"
            ],
					 image: "Initialization42",
					 optionA: "Первая",
					 optionB: "Вторая",
					 optionC: "Третья",
					 optionD: "Четвертая",
					 id: 827385202,
                     helpText: """
                     Первая. Так выглядит первая фаза инициализации для гипотетического подкласса и суперкласса: Инициализация начинается с вызова вспомогательного инициализатора а подкласса.
                     
                     Вспомогательный инициализатор (Convenience init) пока не может изменять каких-либо свойств. Он делегирует назначенному инициализатору по тому же классу, где и он сам. Назначенный инициализатор (Designated init) убеждается, что все свойства, подкласса имеют значения.
                     
                     После этого он вызывает назначенный инициализатор (Designated init) своего суперкласса для продолжения. Назначенный инициализатор суперкласса проверяет наличие значений у всех свойств суперкласса. Сразу после того как все свойства суперкласса получают начальные значения, память считается полностью инициализированной, Фаза 1 завершается.
                     """),
			
			Question(question: [
                "Какая фаза инициализации для гипотетического подкласса и суперкласса на изображении?",
                "На изображении эта фаза инициализации для гипотетического подкласса и суперкласса"
            ],
					 image: "Initialization43",
					 optionA: "Вторая",
					 optionB: "Первая",
					 optionC: "Третья",
					 optionD: "",
					 id: 200872205,
                     helpText: """
                     Вторая. Фаза №2 - Назначенный инициализатор (Designated init) суперкласса только теперь получает возможность менять дальнейшие экземпляры (хотя и не обязан).
                     
                     Как только назначенный инициализатор суперкласса заканчивает работу, получает возможность вносить изменения назначенный инициализатор подкласса (хотя он так же и не обязан это делать).
                     
                     Наконец, как только заканчивает работу назначенный инициализатор подкласса, то возможность вносить изменения получает вспомогательный инициализатор (Convenience init), который изначально был вызван. То есть если рассмотреть весь процесс отдаленно, то он получается, как бы, идет вверх, а потом спускается вниз.
                     """),
			
			Question(question: [
                "Подклассы в Swift не наследуют инициализаторов их суперклассов по умолчанию, так ли это?",
                "Наследуют ли подклассы в Swift инициализаторы их суперклассов по умолчанию?",
                "Могут ли подклассы наследовать инициализаторы суперклассов по умолчанию?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 857737344,
                     helpText: """
                     Да. В отличии от подклассов в Objective-C, подклассы в Swift не наследуют инициализаторов их суперклассов по умолчанию.
                     
                     Такой подход в Swift предотвращает ситуации, когда простой инициализатор суперкласса наследуется более специфичным подклассом, а потом используется для создания экземпляра подкласса, который не полностью или не правильно инициализирован.
                     
                     Инициализаторы суперкласса наследуются в определенных обстоятельствах, но только когда это безопасно и когда это имеет смысл делать.
                     """),
			
			Question(question: [
                "Какой модификатор мы должны писать перед тем, как переопределить инициализатор суперкласса внутри подкласса?",
                "Этим модификатором мы должны помечать инициализатор суперкласса внутри подкласса (переопределение)"
            ],
					 image: "",
					 optionA: "override",
					 optionB: "static",
					 optionC: "private",
					 optionD: "super",
					 id: 738422787,
                     helpText: """
                     override. Если вы хотите, чтобы у вашего подкласса были один или более инициализаторов его суперклассов, вы можете сделать свою реализацию этих инициализаторов внутри подкласса.
                     
                     Когда вы пишете инициализатор подкласса, который совпадает с назначенным инициализатором суперкласса, вы фактически переопределяете назначенный инициализатор (Designated init). Таким образом вы должны писать модификатор override перед определением инициализатора подкласса.
                     
                     Это верно даже если вы переопределяете автоматически предоставляемый инициализатор.
                     """),
			
			Question(question: [
                "Должны ли мы использовать модификатор override, если написали инициализатор подкласса, который совпадает с вспомогательным инициализатором (Convenience init) суперкласса?",
                "Если наш инициализатор подкласса совпадает со вспомогательным инициализатором (Convenience init) суперкласса, должны ли мы использовать модификатор override?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "При любом совпадении",
					 optionD: "",
					 id: 187078387,
                     helpText: """
                     Нет. И наоборот, если вы пишете инициализатор подкласса, который совпадает с вспомогательным инициализатором (Convenience init) суперкласса, то этот вспомогательный инициализатор суперкласса никогда не сможет быть вызван напрямую вашим подклассом, в соответствии с правилами указанными выше.
                     
                     Таким образом ваш подкласс не проводит переопределение инициализатора суперкласса. И в результате, вы не пишете модификатор override, когда проводите совпадающую реализацию вспомогательного инициализатора суперкласса.
                     """),
			
			Question(question: [
                "Могут ли подклассы менять унаследованные переменные свойства в процессе инициализации?",
                "В процессе инициализации подклассы могут менять унаследованные переменные свойства, так ли это?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "Только неизменяемые",
					 optionD: "",
					 id: 721722091,
					 helpText: "Да. Подклассы могут менять унаследованные переменные свойства в процессе инициализации, но нельзя менять неизменяемые унаследованные свойства."),
			
			Question(question: [
                "Будет ли подкласс наследовать все назначенные инициализаторы (Designated init) суперкласса, если сам не определяет ни одного?",
                "Ваш подкласс будет наследовать все назначенные инициализаторы (Designated init) суперкласса, если сам не определяет ни одного назначенного инициализатора. Так ли это?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 586996644,
					 helpText: "Да. Если ваш подкласс не определяет ни одного назначенного инициализатора (Designated init), он автоматически наследует все назначенные инициализаторы суперкласса."),
			
			Question(question: [
                "Если у класса есть реализация всех назначенных инициализаторов (Designated init) его суперкласса, будет ли он автоматически наследовать все вспомогательные инициализаторы (Convenience init) этого суперкласса?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 431314243,
                     helpText: """
                     Да. Если у вашего класса есть реализация всех назначенных инициализаторов (Designated init) его суперкласса, либо они были унаследованы (если ваш подкласс не определяет ни одного назначенного инициализатора, он автоматически наследует все назначенные инициализаторы суперкласса) или же представлены как часть пользовательской реализации определения подкласса, то тогда этот подкласс автоматически наследует все вспомогательные инициализаторы (Convenience init) суперкласса.
                     """),
			
			Question(question: [
                "Что мы можем использовать, если нужно определить класс, структуру или перечисление, инициализация которого может не сработать?",
                "Иногда бывает нужно определить класс, структуру или перечисление, инициализация которого может не сработать (такое неисполнение, например, может быть вызвано некорректными значениями параметров). Что мы можем использовать?"
            ],
					 image: "",
					 optionA: "Failable init",
                     optionB: "Required init",
					 optionC: "Designated init",
					 optionD: "Convenience init",
					 id: 559107874,
                     helpText: """
                     Failable init (проваливающийся инициализатор). Иногда бывает нужно определить класс, структуру или перечисление, инициализация которого может не сработать, провалиться.
                     
                     Такое неисполнение может быть вызвано некорректными значениями параметров или отсутствием требуемого внешнего источника данных или еще какое-нибудь обстоятельство, которое может не позволить завершить инициализацию успешно.
                     
                     Для того чтобы справиться с условиями инициализации, которые могут провалиться, определите один или несколько проваливающихся инициализаторов как часть определения класса, структуры или перечисления. Вы можете написать проваливающийся инициализатор поместив вопросительный знак после ключевого слова init (init?).
                     """),
			
			Question(question: [
                "Можем ли мы определить проваливающийся инициализатор (Failable init) и обычные инициализаторы с одними и теми же именами и типами параметров?",
                "Мы можем определить проваливающийся инициализатор (Failable init) и обычные инициализаторы с одними и теми же именами и типами параметров, так ли это?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "Иногда",
					 optionD: "",
					 id: 605878210,
                     helpText: """
                     Нет. Вы не можете определить проваливающийся  (Failable init) и обычные инициализаторы с одними и теми же именами и типами параметров. Проваливающийся инициализатор создает опциональное значение типа, который он инициализирует.
                     
                     Вы пишете return nil внутри проваливающегося инициализатора для индикации точки, где инициализация может провалиться.
                     """),
			
			Question(question: [
                "Как пишется проваливающийся инициализатор (Failable init)?"
            ],
					 image: "",
					 optionA: "init?() { }",
					 optionB: "init()? { }",
					 optionC: "init(?) { }",
					 optionD: "",
					 id: 316680741,
                     helpText: """
                     init?() { }. Для того чтобы справиться с условиями инициализации, которые могут провалиться, определите один или несколько проваливающихся инициализаторов как часть определения класса, структуры или перечисления.
                     
                     Вы можете написать проваливающийся инициализатор (Failable init) поместив вопросительный знак после ключевого слова init (init?).
                     """),
			
			Question(question: [
                "Можем ли мы использовать проваливающийся инициализатор (Failable init) для перечислений?",
                "Вы можете использовать проваливающийся инициализатор (Failable init) для выбора подходящего члена перечисления, основываясь на одном или более параметров. Так ли это?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 875904274,
					 helpText: "Да. Вы можете использовать проваливающийся инициализатор (Failable init) для выбора подходящего члена перечисления основываясь на одном или более параметров. Инициализатор может провалиться, если предоставленные параметры не будут соответствовать подходящему члену перечисления."),
			
			Question(question: [
                "Какой инициализатор по умолчанию получают перечисления с начальными значениями (rawValue)?",
                "Этот инициализатор по умолчанию получит перечисление с установленными начальными значениям (rawValue)"
            ],
					 image: "",
					 optionA: "Проваливающийся (Failable)",
					 optionB: "Назначенный (Designated)",
					 optionC: "Вспомогательный (Convenience)",
					 optionD: "Требуемый (Required)",
					 id: 401031814,
                     helpText: """
                     Проваливающийся (Failable). Перечисления с начальными значениями по умолчанию получают проваливающийся инициализатор init?(rawValue:), который принимает параметр rawValue подходящего типа и выбирает соответствующий член перечисления, если он находит подходящий, или срабатывает сбой инициализации, если существующее значение не находит совпадения среди членов перечисления.
                     """),
			
			Question(question: [
                "Может ли проваливающийся инициализатор (Failable init) класса, структуры, или перечисления быть делегирован другому проваливающемуся инициализатору из того же класса?",
                "Может ли проваливающийся инициализатор (Failable init) подкласса быть делегирован наверх в проваливающийся инициализатор суперкласса?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 206768942,
					 helpText: "Да. Проваливающийся инициализатор (Failable init) класса, структуры, перечисления может быть делегирован к другому проваливающемуся инициализатору из того же класса, структуры, перечисления. Аналогично проваливающийся инициализатор подкласса может быть делегирован наверх в проваливающийся инициализатор суперкласса."),
			
			Question(question: [
                "Какой инициализатор мы будем использовать, когда нам нужно, чтобы каждый подкласс этого класса был обязан реализовать его?"
            ],
					 image: "",
					 optionA: "Требуемый (Required)",
					 optionB: "Назначенный (Designated)",
					 optionC: "Вспомогательный (Convenience)",
					 optionD: "Почленный (Memberwise)",
					 id: 132251335,
					 helpText: "Требуемый (Required). Напишите Required перед определением инициализатора класса, если вы хотите, чтобы каждый подкласс этого класса был обязан реализовывать этот инициализатор."),
			
			Question(question: [
                "Каким ключевым словом обозначается требуемый инициализатор?",
                "Требуемый инициализатор обозначается этим ключевым словом"
            ],
					 image: "",
					 optionA: "Required",
					 optionB: "convenience",
					 optionC: "override",
					 optionD: "",
					 id: 344047799,
					 helpText: "Required. Напишите Required перед определением инициализатора класса, если вы хотите, чтобы каждый подкласс этого класса был обязан реализовывать этот инициализатор."),
			
			Question(question: [
                "Мы обязаны писать override каждый раз, когда переопределяем требуемый инициализатор (Required init). Это так?",
                "Обязаны ли мы писать override всегда, когда переопределяем требуемый инициализатор (Required init) суперкласса?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "",
					 optionD: "",
					 id: 350209500,
					 helpText: "Нет. Вы также должны писать модификатор Required перед каждой реализацией требуемого инициализатора класса для индикации того, что последующий подкласс так же должен унаследовать этот инициализатор по цепочке. Вы не пишете override, когда переопределяете требуемый инициализатор (Required init)."),
			
			Question(question: [
                "Обязаны ли мы обеспечивать явную реализацию требуемого инициализатора (Required init) в подклассах, если нам достаточно унаследованного?",
                "Если мы можем удовлетворить требования инициализации унаследованным инициализатором суперкласса, должны ли мы явно реализовывать требуемый инициализатор (Required init) в нашем подклассе?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "",
					 optionD: "",
					 id: 300682311,
					 helpText: "Нет. Вы не должны обеспечивать явную реализацию требуемого инициализатора (Required init), если вы можете удовлетворить требование унаследованным инициализатором."),
			
			Question(question: [
                "Можете ли вы установить дефолтное значение свойства подобным образом?",
            ],
					 image: "Initialization01",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 387118598,
                     helpText: """
                     Да. Если дефолтное значение свойства требует какой-то донастройки, то вы можете использовать замыкание или глобальную функцию, которая будет предоставлять значение для этого свойства.
                     
                     Как только создается новый экземпляр, вызывается функция или замыкание, которая возвращает значение, которое присваивается в качестве дефолтного значения свойства.
                     
                     Эти виды замыканий обычно создают временное значение того же типа, что и свойство, используя эту величину для отображения желаемого начального состояния, затем возвращают ее в качестве начального значения свойства.
                     """),
			
			Question(question: [
                "Обязаны ли мы использовать круглые скобки после замыкания?",
                "Должны ли мы писать круглые скобки после замыкания?"
            ],
					 image: "Initialization01",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "На ваше усмотрение",
					 optionD: "",
					 id: 976269928,
                     helpText: """
                     Да. Обратите внимание, что после закрывающей фигурной скобки замыкания идут пустая пара круглых скобок. Это говорит Swift, что нужно исполнить это замыкание немедленно.
                     
                     Если вы пропустите эти скобки, то вы присваиваете само значение замыкания свойству, а не возвращаете значения замыкания.
                     """),
			
			Question(question: [
                "Если мы используем замыкание для инициализации свойства, можем ли мы обращаться к остальной части нашего экземпляра в момент, когда это замыкание исполняется?",
                "Если для инициализации свойства мы используем замыкание, можем ли мы обращаться из него к остальным свойствам нашего экземпляра?",
                "Когда для инициализации свойства мы используем замыкание, можем ли мы внутри него обращаться к self?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "",
					 optionD: "",
					 id: 190939340,
                     helpText: """
                     Нет. Если вы используете замыкание для инициализации свойства, помните, что остальная часть экземпляра еще не инициализирована, на тот момент когда исполняется замыкание.
                     
                     Это значит, что вы не можете получить доступ к значениям других свойств из вашего замыкания, даже если эти свойства имеют начальное значение.
                     
                     Вы так же не можете использовать неявное свойство self и не можете вызвать какой-либо метод вашего экземпляра.
                     """)
		]
	}
}
