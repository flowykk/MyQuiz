
//  Created by Евгений Никитин on 10.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

final class CollectionsSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Какая из этих строк создаст массив, словарь, или кортеж?"],
                     image: "Collections09",
                     optionA: "Первая",
                     optionB: "Вторая",
                     optionC: "",
                     optionD: "",
                     id: 357650604,
                     helpText: """
                     Первая. В первой строке мы создаем кортеж, во второй у нас будет ошибка компиляции, поскольку мы не можем создать словарь таким образом, без круглых скобок после указания типа словаря.
                     
                     Корректная запись будет выглядеть так: var counter = [String: Double]().
                     """),
            
            Question(question: ["Можем ли мы по ошибке вставить значение неверного типа в коллекцию?",
                                "Можем ли мы вставить значение неверного типа в массив?",
                                "Возможно ли вставить значение неверного типа в словарь? "],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 575408226,
                     helpText: """
                     Нет. Массивам, множествам и словарям в Swift всегда понятно, какие типы значений и ключи они могут хранить.
                     
                     Это означает, что вы не можете по ошибке вставить неверное значение в коллекцию. Это также означает, что вы можете быть уверены в типах значений, которые вы получите из коллекции.
                     """),
            
            Question(question: ["Какое значение будет в переменной length?"],
                     image: "Collections01",
                     optionA: "5",
                     optionB: "6",
                     optionC: "4",
                     optionD: "",
                     id: 379461209,
                     helpText: """
                     5. При инициализации массива firstArray в secondArray - мы создаем копию этого массива, и изменяя один из экземпляров - никак не влияем на второй (все стандартные типы в Swift являются типами значения - value types).
                     
                     При добавлении числа 6 в secondArray через .append, в firstArray у нас так и останется 5 элементов.
                     """),
            
            Question(question: ["Если принципиально важно, чтобы значения в коллекции не повторялись, какой тип вы будете использовать?",
                                "Какой тип коллекции вы будете использовать, если важно, чтобы значения внутри не повторялись?",
                                "Какую коллекцию вы будете использовать, чтобы внутри все значения были уникальными?"],
                     image: "",
                     optionA: "Множество",
                     optionB: "Массив",
                     optionC: "Словарь",
                     optionD: "",
                     id: 237104495,
                     helpText: """
                     Множество. Множество хранит различные значения одного типа в виде коллекции в неупорядоченной форме.
                     
                     Вы можете использовать множества как альтернативы массиву, когда порядок для вас значения не имеет или когда вам нужно быть уверенным в том, что значения внутри коллекции не повторяются.
                     """),
            
            Question(question: ["Какие значения мы получим в консоль после запуска этого кода?"],
                     image: "Collections02",
                     optionA: "false, true",
                     optionB: "false, false",
                     optionC: "true, false",
                     optionD: "true, true",
                     id: 754078264,
                     helpText: """
                     false, true. При сравнении array и array2 мы получим false, потому что массивы сравниваются как есть, и наши массивы содержат разное количество элементов, соответственно - они не могут быть равны.
                     
                     Но когда мы приводим наши массивы к множествам, в которых элементы не могут дублироваться (множество это коллекция уникальных элементов) - мы удаляем повторяющиеся значения, и у нас остаются одинаковые элементы в равных количествах.
                     """),
            
            Question(question: ["Какие значения мы получим в консоль после запуска этого кода?"],
                     image: "Collections03",
                     optionA: "false, false",
                     optionB: "false, true",
                     optionC: "true, false",
                     optionD: "true, true",
                     id: 127980411,
                     helpText: "false, false. Как массивы, так и наборы (после удаления дублирующихся значений), будут содержать разные элементы. Поэтому оба сравнения дадут нам false."),
            
            Question(question: ["Последовательность (Sequence), в которой можно обращаться к отдельному элементу напрямую"],
                     image: "",
                     optionA: "Коллекция",
                     optionB: "Кортеж",
                     optionC: "Опционал",
                     optionD: "",
                     id: 857640149,
                     helpText: """
                     Коллекция (Collection). Это последовательность (Sequence), в которой можно обращаться к отдельному элементу напрямую.
                     
                     Другими словами, Collection — это протокол, основанный на протоколе Sequence, который при этом имеет дополнительное требование по обеспечению прямого доступа к элементам. Также коллекция не может быть бесконечной (в отличие от Sequence).
                     """),
            
            Question(question: ["Сколько основных типов коллекций обеспечивает Swift?",
                                "Swift поддерживает именно столько основных типов коллекций",
                                "Какое количество типов коллекций поддерживается в Swift?"],
                     image: "",
                     optionA: "Три",
                     optionB: "Два",
                     optionC: "Четыре",
                     optionD: "Пять",
                     id: 571685140,
                     helpText: "Три. Swift обеспечивает три основных типа коллекций - это Массивы, Множества и Словари для хранения коллекций значений."),
            
            Question(question: ["Упорядоченная коллекция значений",
                                "Коллекция с упорядоченными значениями",
                                "Упорядоченные значения, объединенные в коллекцию"],
                     image: "",
                     optionA: "Массив",
                     optionB: "Словарь",
                     optionC: "Множество",
                     optionD: "",
                     id: 981639342,
                     helpText: "Массив. Массивы - это упорядоченные коллекции значений. Массивы хранят много значений одинакового типа в упорядоченном списке. Одно и то же значение в массиве может появиться несколько раз, в разных позициях."),
            
            Question(question: ["Неупорядоченная коллекция уникальных значений",
                                "Уникальные значения, собранные в неупорядоченную коллекцию",
                                "Коллекция неупорядоченных уникальных значений"],
                     image: "",
                     optionA: "Множество",
                     optionB: "Массив",
                     optionC: "Словарь",
                     optionD: "",
                     id: 355306978,
                     helpText: "Множество. Множества - это неупорядоченные коллекции уникальных значений."),
            
            Question(question: ["Неупорядоченная коллекция, хранящая пары ключ-значение",
                                "Коллекция, хранящая неупорядоченные пары ключ-значение",
                                "Неупорядоченные пары ключ-значение хранятся именно в этой коллекции"],
                     image: "",
                     optionA: "Словарь",
                     optionB: "Множество",
                     optionC: "Массив",
                     optionD: "",
                     id: 308436207,
                     helpText: """
                     Словарь. Словари - это неупорядоченные коллекции, хранящие пары ключ-значение. Словарь представляет собой контейнер, который хранит несколько значений одного и того же типа.
                     
                     Каждое значение связано с уникальным ключом, который выступает в качестве идентификатора этого значения внутри словаря.
                     
                     В отличие от элементов в массиве, элементы в словаре не имеют определенного порядка. Используйте словарь, когда вам нужно искать значения на основе их идентификатора, так же как в реальном мире словарь используется для поиска определения конкретного слова.
                     """),
            
            Question(question: ["Какой тип коллекции на изображении?"],
                     image: "Collections5",
                     optionA: "Словарь",
                     optionB: "Множество",
                     optionC: "Массив",
                     optionD: "",
                     id: 438685776,
                     helpText: "Словарь. На изображении словарь, коллекция пар ключ-значение"),
            
            Question(question: ["Какой тип коллекции на изображении?",
                                "Укажите какой тип коллекции изображен на изображении?",
                                "На этом изображении именно этот тип коллекции"],
                     image: "Collections8",
                     optionA: "Массив",
                     optionB: "Множество",
                     optionC: "Набор",
                     optionD: "Словарь",
                     id: 184948656,
                     helpText: "Массив. На изображении массив, упорядоченная коллекция значений, доступных по индексу."),
            
            Question(question: ["Какой тип коллекции на изображении?",
                                "Укажите какой тип коллекции показан на изображении?",
                                "На этом изображении именно этот тип коллекции"],
                     image: "Collections9",
                     optionA: "Множество",
                     optionB: "Массив",
                     optionC: "Словарь",
                     optionD: "",
                     id: 100663625,
                     helpText: "Множество. На изображении множество, неупорядоченная коллекция уникальных значений."),
            
            Question(question: ["Если коллекция присвоена константе, можем ли мы ее изменять?",
                                "Можем ли мы изменять словарь или массив, если он присвоен константе?",
                                "Возможно ли изменять множество, если при создании мы присвоили его константе?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Можем добавлять элементы",
                     optionC: "Можем удалять элементы",
                     optionD: "Да",
                     id: 789561026,
                     helpText: """
                     Нет. Когда вы присвоите массив или словарь константе, то он будет неизменяемым, а его размер и содержимое не может быть изменено.
                     
                     Хорошей практикой является создание неизменяемых коллекций во всех случаях, когда коллекцию не нужно менять. Делая это, мы позволяем компилятору Swift оптимизировать производительность наших коллекций.
                     """),
            
            Question(question: ["Как пишется полная форма записи массива в Swift?",
                                "Полная форма записи массива в Swift пишется так",
                                "Как нужно писать полную форму записи массива в Swift?"],
                     image: "",
                     optionA: "Array<ElementType>",
                     optionB: "[ElementType]",
                     optionC: "[ElementType]()",
                     optionD: "Array(ElementType)[]",
                     id: 501843423,
                     helpText: "Array<ElementType>. Полная форма записи массива в Swift пишется Array<ElementType>, где ElementType это тип значений, которые могут храниться в массиве."),
            
            Question(question: ["Что мы используем для доступа к элементам коллекции?"],
                     image: "",
                     optionA: "Индекс",
                     optionB: "Значение элемента",
                     optionC: "Волшебное слово",
                     optionD: "",
                     id: 372971495,
                     helpText: """
                     Индекс. Для доступа к элементам коллекции используются индексы. Они могут быть представлены как в виде обычного числового значения (порядковый номер элемента), так и в виде более сложных структур (как, например, в словарях или строках).
                     
                     То есть обращаясь к коллекции и сообщая ей индекс интересующего вас элемента, вы получите значение именно того элемента, индекс которого передали. Но при этом элементы коллекции точно так же могут последовательно перебираться.
                     """),
            
            Question(question: ["Как пишется сокращенная форма записи массива в Swift?",
                                "Сокращенная форма записи массива в Swift пишется так",
                                "Как нужно писать сокращенную форму записи массива в Swift?"],
                     image: "",
                     optionA: "[ElementType]",
                     optionB: "Array<ElementType>",
                     optionC: "[ElementType]()",
                     optionD: "Array(ElementType)[]",
                     id: 768291993,
                     helpText: "[ElementType]. Вы можете также написать массив в сокращенной форме как [ElementType]. Хотя две формы функционально идентичны, краткая форма является предпочтительной."),
            
            Question(question: ["Как можно создать пустой массив с помощью синтаксиса инициализатора?",
                                "Как вы можете создать пустой массив?",
                                "Пустой массив инициализируется именно так"],
                     image: "",
                     optionA: "var array = [String]()",
                     optionB: "var array = (String)[]",
                     optionC: "var array = [String()]",
                     optionD: "var array: [String]?",
                     id: 703702168,
                     helpText: "var array = [String](). Вы можете создать пустой массив определенного типа с помощью синтаксиса инициализатора: var array = [String]()."),
            
            Question(question: ["Является ли коллекция последовательностью?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 508411585,
                     helpText: """
                     Да. Коллекция (Collection) — это последовательность (Sequence), в которой можно обращаться к отдельному элементу напрямую.
                     
                     Другими словами, Collection — это протокол, основанный на протоколе Sequence, который при этом имеет до- полнительное требование по обеспечению прямого доступа к элементам.
                     
                     Также коллекция не может быть бесконечной (в отличие от Sequence).
                     """),
            
            Question(question: ["Альтернативный способ создания пустого массива",
                                "Альтернативный вариант, как вы можете создать пустой массив",
                                "Пустой массив может инициализироваться именно так"],
                     image: "",
                     optionA: "var array: [String] = []",
                     optionB: "var array: String = []",
                     optionC: "var array = String()",
                     optionD: "var array: [String]?",
                     id: 563632176,
                     helpText: "var array: [String] = []. В качестве альтернативы синтаксису инизиализатора, вы можете создать пустой массив с помощью пустого литерала массива, который записывается в виде [] (пустой пары квадратных скобок)."),
            
            Question(question: ["Какой тип будет у данного массива ints, и что будет внутри?",
                                "Выберите ответ с правильным типом и содержанием коллекции ints",
                                "Выберите тип и содержание данного массива ints"],
                     image: "Collections15",
                     optionA: "№2: [Double] и [0.0, 0.0, 0.0]",
                     optionB: "№1: [Int] и [0, 0, 0]",
                     optionC: "№3: [Double] и [0, 0, 0]",
                     optionD: "",
                     id: 326073251,
                     helpText: "Правильный ответ: №2. Если не указывать иного, Swift присвоит массиву чисел с плавающей точкой тип [Double], а данный инициализатор массива указывает, что в этом массиве должны быть числа 0.0, повторяющиеся три раза. То есть правильный ответ будет [Double], [0.0, 0.0, 0.0]."),
            
            Question(question: ["Как мы можем создать новый массив, объединив два существующих массива с совместимыми типами?",
                                "Каким образом мы можем создать новый массив из двух существующих (их типа совместимы)?",
                                "Из двух существующих массивов с одинаковым типом необходимо создать новый, как это сделать?"],
                     image: "",
                     optionA: "Сложить (+)",
                     optionB: "Используя интерполяцию",
                     optionC: "Через свойство .insert",
                     optionD: "Логическим оператором И &&",
                     id: 461226350,
                     helpText: """
                     Сложить (+). Вы можете создать новый массив, объединив два существующих массива с совместимыми типами с оператором сложения (+).
                     
                     Новый тип массива выводится из типа двух массивов, которые вы объединяете вместе. Так же можно добавить один массив к другому через firstArray.append(contentsOf: secondArray).
                     """),
            
            Question(question: ["Корректен ли данный код работы с массивом в Swift?"],
                     image: "Collections14",
                     optionA: "Нет, будет ошибка",
                     optionB: "Да, корректен",
                     optionC: "",
                     optionD: "",
                     id: 994895160,
                     helpText: "Нет, будет ошибка. Swift не поддерживает такое поведение массивов, добавлять или убирать элементы необходимо через нативные функции, такие как .append, .remove и так далее. В нашем случае - мы получим ошибку компиляции (No exact matches in call to subscript)."),
            
            Question(question: ["Выберите создание массива через синтаксис литерала массива",
                                "Какой из этих способов описывается как «создание массива через литерал массива»?",
                                "Мы можем создать массив с помощью синтаксиса литерала массива именно так"],
                     image: "",
                     optionA: "var nums: [Int] = [0, 1, 2, 3]",
                     optionB: "var nums: Int = [0, 1, 2, 3]",
                     optionC: "var nums: [Int] = 0, 1, 2, 3",
                     optionD: "var nums: [Int](0, 1, 2, 3)",
                     id: 874476168,
                     helpText: """
                     var nums: [Int] = [0, 1, 2, 3]. Вы можете инициализировать массив с помощью литерала массива, который является быстрым способом писать одно или несколько значений как набор значений массива.
                     
                     Литерал массива пишется в виде списка значений, разделенных запятыми и окруженными парами скобок: [value 1, value 2, value 3].
                     
                     Пример: создается массив под названием numbers для хранения Int значений: var number: [Int] = [1, 2, 3, 4, 5].
                     """),
            
            Question(question: ["В каком из этих случаев мы можем не указывать тип массива?",
                                "Выберите вариант, в котором мы можем убрать указание типа массива, и это не вызовет ошибку?",
                                "Выберите вариант, при котором мы можем убрать явное указание типа массива?"],
                     image: "",
                     optionA: "var array: [Int] = [1, 2]",
                     optionB: "var array = [String]()",
                     optionC: "var array = [Int](1, 2, 3)",
                     optionD: "var array = []",
                     id: 374489271,
                     helpText: """
                     var array: [Int] = [1, 2]. Благодаря выводу типов Swift, вы можете не писать тип для массива, который вы инициализируйте с помощью литерала массива, хранящего значения того же типа, например var array: [Int] = [1, 2].
                     
                     Вместо этого, инициализация array может быть записана в сокращенной форме: var array = [1, 2]. Поскольку все значения внутри литерала массива одинакового типа (Int), Swift может вывести, что [Int] является правильным типом для переменной array.
                     """),
            
            Question(question: ["Быстрый способ получить количество элементов массива?",
                                "Получить количество элементов массива можно через это свойство",
                                "Какое свойство поможет вам получить количество элементов массива?"],
                     image: "",
                     optionA: "array.count",
                     optionB: "array.sort()",
                     optionC: "array.prefix()",
                     optionD: "array.append()",
                     id: 421477900,
                     helpText: "count. Чтобы узнать количество элементов в массиве, проверьте его свойство count."),
            
            Question(question: ["Что выведется в консоль после запуска данного кода?",
                                "Какой результат запуска мы увидим в консоли?",
                                "Выберите вариант, который окажется в консоли после запуска этого кода"],
                     image: "Collections20",
                     optionA: "Array is empty",
                     optionB: "Array is not empty",
                     optionC: "Ничего не выведет",
                     optionD: "Столкнемся с ошибкой",
                     id: 742701915,
                     helpText: """
                     Array is empty. Логическое свойство isEmpty можно использовать в качестве быстрого способа узнать, является ли свойство count равным 0.
                     
                     В данном примере у нас пустой массив array, значит мы пройдем проверку по первому условию и выведем «Array is empty»
                     """),
            
            Question(question: ["Куда добавляется элемент, когда мы вносим его в массив через .append?",
                                "Как добавится элемент, когда мы вставляем его в массив через .append?",
                                "Если мы добавим элемент в массив через .append, куда он поместится?"],
                     image: "",
                     optionA: "В конец массива",
                     optionB: "В начало массива",
                     optionC: "Посередине",
                     optionD: "",
                     id: 665837498,
                     helpText: "В конец массива. Через вызов метода append вы можете добавлять новые элементы в конец массива."),
            
            Question(question: ["Какой результат мы получим, после запуска этого кода?"],
                     image: "Collections22",
                     optionA: "Столкнемся с ошибкой",
                     optionB: "[0.1, 1.1, 1.2, 2.2, 3.4]",
                     optionC: "Массив не изменится",
                     optionD: "Ничего",
                     id: 159946881,
                     helpText: "Столкнемся с ошибкой. Добавить массив с одним или несколькими совместимыми (типами) элементами можно с помощью оператора сложения с присвоением (+=), но в данном случае мы столкнемся с ошибкой, поскольку numbers является константой."),
            
            Question(question: ["Что будет содержаться внутри массива numbers после выполнения этого кода?",
                                "Какие значения будут содержаться внутри numbers в результате?",
                                "Выберите верный вариант итогового вида массива numbers"],
                     image: "Collections23",
                     optionA: "№3: [1.0, 2.0, 3.0, 4.0, 5.0]",
                     optionB: "№1: [1.0, 2.0, 3, 4, 5]",
                     optionC: "№2: [1, 2, 3, 4, 5]",
                     optionD: "",
                     id: 739767869,
                     helpText: "Правильный ответ: №3. [1.0, 2.0, 3.0, 4.0, 5.0]. Оператор присваивания со сложением добавит в данный массив значения 3, 4 и 5, но, так как массив numbers имеет тип [Double], значения примут вид 3.0, 4.0, 5.0."),
            
            Question(question: ["Как с помощью синтаксиса сабскриптов извлечь значение из массива?",
                                "В каком из вариантов используется корректное обращение к элементу массива с помощью синтаксиса сабскриптов?",
                                "Как выглядит извлечение из массива с помощью синтаксиса сабскриптов?"],
                     image: "",
                     optionA: "arrayName[1]",
                     optionB: "arrayName(0)",
                     optionC: "arrayName-2",
                     optionD: "arrayName.3",
                     id: 488128173,
                     helpText: "arrayName[1]. Можно извлечь значение из массива с помощью синтаксиса сабскриптов, поместив индекс значения, который вы хотите получить, внутри квадратных скобок сразу после имени массива. Первый элемент в массиве имеет индекс 0, а не 1. Массивы в Swift всегда начинаются с 0."),
            
            Question(question: ["Какие элементы будут в массиве numbers после выполнения данного кода?",
                                "Выберите итоговый порядок элементов массива numbers после исполнения данного кода",
                                "После выполнения кода, какой порядок элементов будет у массива numbers?"],
                     image: "Collections25",
                     optionA: "№1: [1.0, 2.0, 1.0, 4.0]",
                     optionB: "№2: [1.0, 2.0, 3.0, 4.0]",
                     optionC: "№3: [1.0, 2.0, 3.0, 1.0]",
                     optionD: "",
                     id: 112337298,
                     helpText: """
                     Правильный ответ: №1. [1.0, 2.0, 1.0, 4.0]. Вы можете использовать синтаксис сабскриптов для изменения существующего значения по указанному индексу.
                     
                     Поскольку мы инициализируем новое значение элементу массива, который находится на индексе [2], начиная с 0 это будет третий элемент (3.0).
                     """),
            
            Question(question: ["Вызов какого метода поможет вставить элемент в массив на определенный индекс?",
                                "Чтобы вставить элемент на определенный индекс массива, какой мы будем использовать метод?",
                                "Какой метод нужно использовать, чтобы вставить элемент на определенный индекс массива?"],
                     image: "",
                     optionA: "insert(_:at:)",
                     optionB: ".append",
                     optionC: "add(_:at:)",
                     optionD: "remove(_ :at:)",
                     id: 287081136,
                     helpText: "insert(_:at:). Для вставки элемента по заданному индексу внутрь массива, вызовите его метод insert(_:at:)."),
            
            Question(question: ["Вызов какого метода поможет удалить элемент из массива с определенного индекса?",
                                "Чтобы удалить элемент с определенного индекса массива, какой мы будем использовать метод?",
                                "Какой метод нужно использовать, чтобы удалить элемент с определенного индекса массива?"],
                     image: "",
                     optionA: "remove(_ :at:)",
                     optionB: ".append",
                     optionC: "add(_:at:)",
                     optionD: "insert(_:at:)",
                     id: 38286348,
                     helpText: "remove(_ :at:). Можно удалить элемент из массива с помощью метода remove(at:). Этот метод удаляет элемент с указанным индексом и возвращает удаленный элемент (хотя вы можете проигнорировать возвращаемое значение, если оно вам не нужно)."),
            
            Question(question: ["Что будет, если вы попытаетесь получить доступ или изменить значение индекса, который находится за пределами существующих границ массива?",
                                "Если вы попытаетесь изменить значение индекса, который находится за пределами существующих границ массива, что произойдет?"],
                     image: "",
                     optionA: "Ошибка исполнения",
                     optionB: "Вернется nil",
                     optionC: "Ничего не произойдет",
                     optionD: "Вернется последний элемент",
                     id: 541953975,
                     helpText: """
                     Ошибка исполнения. Если вы пытаетесь получить доступ или изменить значение индекса, который находится за пределами существующих границ массива, у вас будет ошибка исполнения.
                     
                     Вы можете проверить, действителен ли индекс, прежде чем его использовать, сравнив его с свойством count массива.
                     
                     За исключением случаев, когда count равен 0 (то есть массив пуст), самый большой валидный индекс в массиве всегда будет count - 1, так как массивы индексируются с нуля.
                     """),
            
            Question(question: ["Какие элементы будут содержаться в массиве после выполнения этого кода?",
                                "Выберите какие значения будут содержаться в массиве после исполнения insert и remove?"],
                     image: "Collections30",
                     optionA: "[2, 3, 9, 4, 5]",
                     optionB: "[1, 2, 3, 9, 4, 5]",
                     optionC: "[1, 2, 3, 4, 5]",
                     optionD: "[1, 2, 3, 9, 4]",
                     id: 166266577,
                     helpText: "[2, 3, 9, 4, 5]. Сначала numbers.insert(9, at: 3) добавляет девятку на третий индекс, то есть между тройкой и четверкой, после чего numbers.remove(at: 0) удаляет единицу, которая находится на нулевом индексе. Получается [2, 3, 9, 4, 5]."),
            
            Question(question: ["Как мы можем удалить один или несколько последних элементов массива, при этом вернуть оставшийся массив?",
                                "Каким методом вы можете удалить несколько последних значений массива, и вернуть то, что осталось?",
                                "Выберите метод, который позволит вам удалить несколько последних элементов массива и вернуть оставшееся"],
                     image: "",
                     optionA: "array.dropLast()",
                     optionB: "array.removeLast()",
                     optionC: "array.remove(_ :at:)",
                     optionD: "array.deleteLast()",
                     id: 225059326,
                     helpText: "dropLast(). Если вы хотите удалить последний или несколько последних элементов из массива, вы можете использовать метод dropLast(), в скобках необходимо указать количество элементов, которые вы хотите удалить. После реализации данного метода вам вернется оставшаяся последовательность."),
            
            Question(question: ["Каким методом мы можем удалить последний элемент массива, и сразу вернуть его?",
                                "Какой метод удаляет последний элемент массива, и возвращает его?",
                                "Этим методом можно удалить последний элемент массива и вернуть его"],
                     image: "",
                     optionA: "array.removeLast()",
                     optionB: "array.remove(_ :at:)",
                     optionC: "array.dropLast()",
                     optionD: "array.deleteLast()",
                     id: 448130194,
                     helpText: "removeLast(). Если вы хотите удалить последний элемент из массива, то можно использовать метод removeLast() вместо remove(at:), чтобы избежать необходимости запроса свойства count для массива. Также как и метод remove(at:), removeLast() возвращает удаленный элемент."),
            
            Question(question: ["Какими будут значения переменных first и second?",
                                "Выберите, какими будут значения переменных first и second"],
                     image: "Collections34",
                     optionA: "[1, 2, 3] и 4",
                     optionB: "[1, 2, 3, 4] и 4",
                     optionC: "[1, 2, 3, 4, 5] и 5",
                     optionD: "[1, 2, 3, 4] и 5",
                     id: 686187366,
                     helpText: """
                     [1, 2, 3] и 4. Первое выражение var first = numbers.dropLast() присвоит переменной first массив с оставшимися элементами, это [1, 2, 3, 4].
                     
                     Второе выражение var second = first.removeLast() присвоит переменной second последний элемент массива first, то есть цифру 4, но при этом он удалит ее из этой переменной, и там останется только [1, 2, 3].
                     """),
            
            Question(question: ["Каким образом можно выполнить самое просто итерирование массива?",
                                "Этим способом можно выполнить простое итерирование массива, возвращая только элементы без индексов",
                                "Как мы можем выполнить просто итерирование массива, чтобы возвращать только элементы без индексов?"],
                     image: "",
                     optionA: "цикл for-in",
                     optionB: "цикл while",
                     optionC: "enumerated()",
                     optionD: "switch-case",
                     id: 654991144,
                     helpText: """
                     цикл for-in. Вы можете выполнить итерацию по всему набору значений внутри массива с помощью цикла for-in.
                     
                     Но если вам нужен целочисленный индекс каждого значения так же как и само значение, используйте вместо этого глобальную функцию enumerated() для итерации по массиву.
                     
                     Функция enumerated() возвращает кортеж для каждого элемента массива, собрав вместе индекс и значение для этого элемента.
                     """),
            
            Question(question: ["Каким образом мы можем итерировать массив, чтобы вернуть кортежи значений, содержащие индекс и значение, находящееся на этом индексе?",
                                "Этим способом можно итерировать массив, возвращая кортежи значений, состоящие из индекса и значения, находящегося на этом индексе",
                                "С помощью этой глобальной функции мы можем итерировать массив и вернуть кортежи, состоящие из индексов и значений, находящихся на этих индексах."],
                     image: "",
                     optionA: "for-in и enumerated()",
                     optionB: "for-in и sorted()",
                     optionC: "repeat-while",
                     optionD: "while",
                     id: 562087283,
                     helpText: """
                     for-in и enumerated(). Если вам нужен целочисленный индекс каждого значения так же как и само значение, используйте глобальную функцию enumerated() для итерации по массиву.
                     
                     Функция enumerated() возвращает кортеж для каждого элемента массива, собрав вместе индекс и значение для этого элемента.
                     
                     При этом вы можете разложить кортеж во временные константы или переменные в рамках итерации: for (index, value) in someArray.enumerated() { print(index, value) }
                     """),
            
            Question(question: ["Какое значение будет у константы first?"],
                     image: "Collections69",
                     optionA: "9",
                     optionB: "10",
                     optionC: "8",
                     optionD: "Столкнемся с ошибкой",
                     id: 908641032,
                     helpText: "9. Числам (индексам) ниже 10 можно приписывать нули. В этой стилистической надстройке нет прямой необходимости, но иногда она может сделать код более читаемым."),
            
            Question(question: ["У стандартных типов коллекций в Swift есть оптимизация, позволяющая сократить затраты на копирование большого количества элементов, из-за нее элементы копируются... ",
                                "Чтобы минимизировать затраты на копирование большого количества элементов у типов коллекций (массив, словарь, строка), в Swift используется данная оптимизация: \"Элементы копируются...\""],
                     image: "",
                     optionA: "Прямо перед модификацией",
                     optionB: "Не копируются",
                     optionC: "В глобальном потоке",
                     optionD: "Специальным алгоритмом",
                     id: 470520042,
                     helpText: """
                     Прямо перед модификацией. Коллекции, определенные стандартной библиотекой, такие как массивы, словари и строки, используют оптимизацию для снижения затрат на копирование.
                     
                     Вместо того, чтобы немедленно сделать копию, эти коллекции совместно используют память, в которой элементы хранятся между исходным экземпляром и любыми копиями. Если одна из копий коллекции модифицирована, элементы копируются непосредственно перед изменением.
                     """),
            
            Question(question: ["Что мы получим в консоль?",
                                "Какие значения мы получим в консоль?"],
                     image: "Collections74",
                     optionA: "[1, 2, 3]",
                     optionB: "0, 1, 2",
                     optionC: "[2, 3, 4]",
                     optionD: "3",
                     id: 130568136,
                     helpText: "[1, 2, 3]. prefix(_ maxLength: Int) возвращает последовательность, состоящую из исходных элементов коллекции, в количестве maxLength, указанном пользователем, начиная с начала исходной последовательности. То есть мы получим [1, 2, 3]."),
            
            Question(question: ["Что мы получим в консоль?"],
                     image: "Collections75",
                     optionA: "[3, 4, 5]",
                     optionB: "[1, 2, 3]",
                     optionC: "[2, 3, 4]",
                     optionD: "3",
                     id: 860936709,
                     helpText: """
                     [3, 4, 5]. suffix(_ maxLength: Int) возвращает последовательность, состоящую из исходных элементов коллекции, в количестве maxLength, указанном пользователем, начиная с конца исходной последовательности.
                     
                     То есть мы получим [3, 4, 5]. Если maxLength превышает количество элементов исходной последовательности - мы получим все ее элементы.
                     """),

            Question(question: ["При фильтрации словаря через .filter исходная коллекция остается неизменной. Так ли это?",
                                "Результатом фильтрации словаря через .filter является новая коллекция того же типа, это правда?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 120284511,
                     helpText: "Да. В результате фильтрации словаря через .filter {} нам вернется новая коллекция того же типа, что и исходная. Старая коллекция остается неизменной."),
            
            Question(question: ["Что будет напечатано в консоль?"],
                     image: "Collections04",
                     optionA: "Set<Int>",
                     optionB: "Set",
                     optionC: "Array",
                     optionD: "Array<Int>",
                     id: 425560646,
                     helpText: "Set<Int>."),
            
            Question(question: [
                "При наличии относительно небольшого объема данных, поиск быстрее выполнится по какой коллекции?"
            ],
                     image: "",
                     optionA: "Dictionary",
                     optionB: "Array",
                     optionC: "Одинаково",
                     optionD: "",
                     id: 641757137,
                     links: [
                        "https://swiftbook.ru/content/languageguide/collection-types/",
                        "https://habr.com/ru/sandbox/173690/"
                     ],
                     helpText: """
                     Dictionary. При поиске элемента на позиции 99_999 в коллекции из 100 тысяч элементов, поиск по множеству (Set) займет ~9 микросекунд, поиск по словарю займет ~50 микросекунд, поиск по массиву займет ~5000 микросекунд.
                     
                     Поиск по словарю происходит намного быстрее, чем поиск по массиву, потому что словарь использует хэш-таблицу для организации данных.

                     В хэш-таблице элементы хранятся в виде пар "ключ-значение". При поиске элемента по ключу, словарь использует хэш-функцию, которая преобразует ключ в определенное числовое значение (хэш).
                     
                     Затем по этому хэшу можно быстро найти соответствующее значение. В худшем случае, словарь имеет постоянное время выполнения для операции поиска, равное O(1), то есть время поиска не зависит от размера данных.

                     С другой стороны, при поиске в массиве, программе приходится последовательно просматривать каждый элемент, чтобы найти нужный.
                     """
                    ),
            
            Question(question: [
                "По какому типу коллекции, содержащей 100 тысяч элементов, поиск произойдет быстрее?"
            ],
                     image: "",
                     optionA: "Set",
                     optionB: "Array",
                     optionC: "Одинаковое время",
                     optionD: "",
                     id: 156570697,
                     links: [
                        "https://swiftbook.ru/content/languageguide/collection-types/",
                        "https://habr.com/ru/sandbox/173690/"
                     ],
                     helpText: """
                     Set. При поиске элемента на позиции 99_999 в коллекции из 100 тысяч элементов, поиск по множеству (Set) займет ~9 микросекунд, поиск по словарю займет ~50 микросекунд, поиск по массиву займет ~5000 микросекунд.
                     
                     Поиск по множеству происходит быстрее из-за хэшируемых значений.
                     
                     Это работает следующим образом: каждый элемент вставляется в определенное место в хэш-таблице с учетом хэш-кода элемента. При поиске элемента в хэш-таблице, система вычисляет хэш-код и сразу переходит к соответствующей ячейке. Это позволяет значительно ускорить процесс поиска.
                     
                     Так же в отличии от словаря, в множестве нет пар "ключ-значение", а элементы внутри коллекции - уникальные, это тоже влияет на результаты поисковой задачи.
                     """
                    ),
        ]
    }
}
