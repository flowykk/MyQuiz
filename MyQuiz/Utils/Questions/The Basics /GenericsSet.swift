
//  Created by Евгений Никитин on 12.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

final class GenericsSet {
	static func getQuestions() -> [Question] {
		return [
			Question(question: [
                "Универсальные шаблоны помогают реализовывать это",
                "Что вы можете создавать с помощью универсальных шаблонов?",
                "Что помогают реализовать универсальные шаблоны?"
            ],
					 image: "",
					 optionA: "Гибкие функции",
					 optionB: "Коллекции",
					 optionC: "Переменные свойства",
					 optionD: "Архитектуру",
					 id: 753354684,
                     helpText: """
                     Гибкие функции. Универсальный код позволяет вам писать гибкие, общего назначения функции и типы, которые могут работать с любыми другими типами, с учетом требований, которые вы определили.
                     
                     Вы можете написать код, который не повторяется и выражает свой контент в ясной абстрактной форме.
                     """),
			
			Question(question: [
                "Используются ли универсальные шаблоны в библиотеках Swift?",
                "Swift использует в своих библиотеках универсальные шаблоны. Так ли это?",
                "Как вы думаете, используются ли универсальные шаблоны в стандартных библиотеках Swift?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 915839255,
                     helpText: """
                     Да. Универсальные шаблоны одна из самых мощных особенностей Swift, и большая часть всех библиотек Swift построена на основе универсального кода. На самом деле вы используете универсальный код все время, даже если вы этого не осознаете.
                     """),
			
			Question(question: [
                "Являются ли Swift Array универсальными?",
                "Являются ли Dictionary универсальными?",
                "Являются ли коллекции Swift Array или Dictionary универсальными?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "Только Dictionary",
					 optionD: "Только Array",
					 id: 346004289,
                     helpText: """
                     Да. Коллекции Swift Array или Dictionary являются универсальными. Вы можете создать массив, который содержит значения типа Int или массив, который содержит значения String, или на самом деле любой другой массив, который может содержать любой другой тип.
                     
                     Аналогично вы создаете словарь, который может содержать значения разных типов, и нет никакого ограничения по типу хранящихся значений.
                     """),
			
			Question(question: [
                "С какими типами могут работать универсальные функции?",
                "Универсальные функции могут работать с этими типами"
            ],
					 image: "",
					 optionA: "С любыми",
					 optionB: "С числовыми",
					 optionC: "С текстовыми",
					 optionD: "Со ссылочными",
					 id: 893583037,
					 helpText: "С любыми. Универсальные функции могут работать с любыми типами."),
			
			Question(question: [
                "Универсальные функции используют заполнитель имени типа, как он традиционно записывается?"
            ],
					 image: "",
					 optionA: "<T>",
					 optionB: "T",
					 optionC: "(T)",
					 optionD: "",
					 id: 543486099,
                     helpText: """
                     <T>. Универсальная функция использует заполнитель имени типа <T> вместо текущего имени типа (Int, String, Double…).
                     
                     Заполнитель имени типа ничего не говорит о том, чем должно являться T, но он говорит о том, что все входящие параметры функции должны быть одного типа T, независимо от того, что такое T. Текущий тип T будет определяться каждый раз, как вызывается функция.
                     
                     Когда между параметром типа и функцией нет значимых отношений, то по традиции именами становятся отдельные буквы, такие как T, U, V.
                     """),
			
			Question(question: [
                "В какой момент выводится тип <T> у универсальных функций?"
            ],
					 image: "",
					 optionA: "Во время вызова функции",
					 optionB: "Когда запускается тело",
					 optionC: "После завершения ее работы",
					 optionD: "Когда объявляем",
					 id: 927680964,
					 helpText: "Во время вызова функции. Каждый раз при вызове универсальной функции тип Т выводится из типов, которые передаются в эту функцию."),
			
			Question(question: [
                "Что здесь является параметром типа?"
            ],
					 image: "Generics8",
					 optionA: "<T>",
					 optionB: "_ a: inout T",
					 optionC: "_ b: inout T",
					 optionD: "temporaryA",
					 id: 713184800,
                     helpText: """
                     <T>. В нашем примере, в функции swapTwoValues(_:_:) заполнитель имени типа T - пример параметра типа. Параметры типа определяют и называют тип наполнителя, и пишутся сразу после имени функции, между угловыми скобками (например, <T>).
                     
                     Как только вы определили параметр типа, то вы можете использовать его в качестве типа параметра функции или как возвращаемый функциональный тип, или как аннотация типа внутри тела функции.
                     
                     В каждом случае заполнитель типа отображается параметром типа, который заменяется на актуальное значение типа при вызове функции.
                     """),
			
			Question(question: [
                "Можем ли мы использовать несколько параметров типа?",
                "Мы можем использовать больше одного параметра типа, записав их через запятую. Это так?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 270571986,
					 helpText: "Да. Вы можете использовать несколько параметров типа, просто вписав их в угловых скобках через запятую."),
			
			Question(question: [
                "В каком стиле мы должны записывать параметры типа?",
                "В параметрах типа имена записываются в этом стиле"
            ],
					 image: "",
					 optionA: "Upper Camel Case",
					 optionB: "Lower Camel Case",
					 optionC: "Без разницы",
					 optionD: "",
					 id: 115051465,
					 helpText: "Upper Camel Case. Всегда давайте параметрам типа имена \"горбатого\" верхнего регистра (Upper Camel Case), чтобы указать, что они являются заполнителем для типа, а не значением. Например <T> или <Parameters>."),
			
			Question(question: [
                "Можем ли мы определять наши универсальные типы?",
                "Позволяет ли Swift, в дополнении к универсальным функциям, определять универсальные типы?",
                "Можете ли вы определять универсальные типы в Swift?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 298392099,
					 helpText: "Да. В дополнение к универсальным функциям, Swift позволяет вам определять ваши универсальные типы. Это к примеру универсальные классы, структуры и перечисления, которые могут работать с любыми типами, наподобие тому, как работают Array или Dictionary."),
			
			Question(question: [
                "Универсальный тип может быть расширен. Так ли это?",
                "Можем ли мы расширять универсальный тип?",
                "Можете ли вы расширить универсальный тип?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 128458472,
                     helpText: """
                     Да. Когда вы расширяете универсальный тип, вы не обеспечиваете список параметров в качестве определения расширения.
                     
                     Вместо этого, список параметров типа, из исходного определения типа, доступен внутри тела расширения, а имена исходных параметров типа используются для ссылки на параметры типа из исходного определения.
                     """),
			
			Question(question: [
                "Когда вы расширяете универсальный тип, должны ли вы обеспечивать список параметров этого типа в качестве определения расширения?",
                "Чтобы пользоваться параметрами универсального типа, при его расширении, должны ли вы его явно обеспечивать в качестве определения расширения?"
            ],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "",
					 optionD: "",
					 id: 896732811,
                     helpText: """
                     Нет. Когда вы расширяете универсальный тип, вы не обеспечиваете список параметров в качестве определения расширения.
                     
                     Вместо этого, список параметров типа, из исходного определения типа, доступен внутри тела расширения, а имена исходных параметров типа используются для ссылки на параметры типа из исходного определения.
                     """),
			
			Question(question: [
                "Как называется процесс, при котором мы говорим универсальному типу, что его параметры должны наследовать от определенного класса или соответствовать определенному протоколу или композиции протоколов."
            ],
					 image: "",
					 optionA: "Ограничения типа",
					 optionB: "Сужение типа",
					 optionC: "Границы типа",
					 optionD: "Оговорка типа",
					 id: 781454817,
                     helpText: """
                     Ограничения типа. Иногда бывает нужно внедрить определенные ограничения типа на типы, которые могут быть использованы вместе с универсальными функциями или универсальными типами.
                     
                     Ограничения типа указывают на то, что параметры типа должны наследовать от определенного класса или соответствовать определенному протоколу или композиции протоколов.
                     
                     Для примера возьмем тип Dictionary, который имеет некоторые ограничения типов, которые могут быть использованы в качестве ключей. Как было описано в главе Словари, тип ключа словаря должен быть хешируемым. Таким образом он должен предоставить способ представить себя уникальным.
                     """),
			
			Question(question: [
                "Можем ли мы определять свои собственные ограничения типа, когда создаем пользовательские универсальные классы?",
                "Когда вы создаете пользовательские классы, вы можете определить свои собственные ограничения типа. Так ли это?"
            ],
					 image: "",
					 optionA: "Да",
					 optionB: "Нет",
					 optionC: "",
					 optionD: "",
					 id: 858574637,
                     helpText: """
                     Да. Вы можете определить свои собственные ограничения типа, когда создаете пользовательские универсальные классы, и эти ограничения предоставляют еще больше возможностей универсальному программированию.
                     
                     Абстрактные понятия, как Hashable, характеризуют типы с точки зрения их концептуальных характеристик, а не их явного типа.
                     """),
			
			Question(question: [
                "Выберите вариант с корректным ограничением типа у дженерик-функции, когда мы требуем, чтобы параметр был подклассом другого класса (SomeClass)"
            ],
					 image: "",
					 optionA: "<T: SomeClass>",
					 optionB: "<T> - SomeClass",
					 optionC: "<T(Someclass)>",
					 optionD: "",
					 id: 723316532,
                     helpText: """
                     <T: SomeClass>. Вы пишете ограничения типа, поместив ограничение единственного класса или протокола после имени параметра типа, и разделив их между собой запятыми, обозначая их в качестве части списка параметров.
                     
                     func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) { // тело функции… }. Эта гипотетическая функция имеет два параметра типа. Первый параметр типа - T, имеет ограничение типа, которое требует чтобы T, было подклассом класса SomeClass.
                     
                     Второй параметр типа - U, имеет ограничение типа, которое требует чтобы U соответствовал протоколу SomeProtocol.
                     """),
			
			Question(question: [
                "Какое ограничение типа необходимо присвоить универсальному типу <T>, чтобы он мог реализовывать поддержку операторов равенства и неравенства?"
            ],
					 image: "",
					 optionA: "Протокол Equatable",
					 optionB: "Hashable",
					 optionC: "Любой суперкласс",
					 optionD: "",
					 id: 749210423,
                     helpText: """
                     Протокол Equtable. Стандартная библиотека Swift определяет протокол Equatable, который требует любой соответствующий ей тип реализовывать равенство оператору равенства (==) и реализовывать неравенство оператору неравенства (!=), для того, чтобы значения этих типов можно было сравнивать между собой.
                     
                     Все стандартные типы Swift автоматически поддерживают протокол Equatable. Любой тип, который удовлетворяет протоколу Equatable, может быть безопасно использован, потому что гарантирована поддержка оператора равенства и неравенства.
                     """),
			
			Question(question: [
                "Каким ключевым словом можно добавить связанный тип к протоколу?"
            ],
					 image: "",
					 optionA: "associatedtype",
					 optionB: "mutating",
					 optionC: "subscript",
					 optionD: "append",
					 id: 276229082,
                     helpText: """
                     associatedtype. При определении протокола бывает нужно определить еще один или более связанных типов в качестве части определения протокола. Связанный тип дает плейсхолдер имени типу, который используется как часть протокола.
                     
                     Фактический тип, который будет использоваться связанным типом не указывается до тех пор, пока не будет принят протокол. Связанные типы указываются при помощи ключевого слова associatedtype.
                     """)
		]
	}
}
