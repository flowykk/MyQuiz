//
//  OpaqueTypeSet.swift
//  Swifty-Quiz
//
//  Created by Евгений Никитин on 04.07.2021.
//  Copyright © 2021 Evel-Devel. All rights reserved.
//

import Foundation

final class OpaqueTypeSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: [
                "Что делает функция или метод с непрозрачным типом возвращаемого значения?"
            ],
                     image: "",
                     optionA: "Скрывает информацию о типе",
                     optionB: "Шифрует информацию о типе",
                     optionC: "Не использует информацию о типе",
                     optionD: "",
                     id: 602614904,
                     helpText: "Скрывает информацию о типе. Функция или метод с непрозрачным типом возвращаемого значения скрывает информацию о типе своего возвращаемого значения."),
            
            Question(question: [
                "Скрытие информации о типе полезно на границах между модулем и кодом, который вызывает модуль, поскольку базовый тип возвращаемого значения может оставаться ___. Каким?"
            ],
                     image: "",
                     optionA: "Закрытым",
                     optionB: "Открытым",
                     optionC: "Идентичным",
                     optionD: "",
                     id: 261664110,
                     helpText: """
                     Закрытым. Скрытие информации о типе полезно на границах между модулем и кодом, который вызывает модуль, поскольку базовый тип возвращаемого значения может оставаться закрытым.
                     
                     В отличие от возврата значения, тип которого является типом протокола, непрозрачные типы сохраняют идентичность типа - компилятор имеет доступ к информации о типе, но клиенты модуля - нет.
                     """),
            
            Question(question: [
                "Непрозрачные типы являются ___ универсальных типов"
            ],
                     image: "",
                     optionA: "противоположностью",
                     optionB: "копией",
                     optionC: "абстракцией",
                     optionD: "",
                     id: 953066587,
                     helpText: """
                     Противоположностью. Вы можете думать о непрозрачном типе как о противоположности универсального типа.
                     
                     Универсальные типы позволяют коду, вызывающему функцию, выбирать тип для параметров этой функции и возвращать значение таким образом, чтобы абстрагироваться от реализации функции.
                     """),
            
            Question(question: [
                "Можете ли вы комбинировать непрозрачные возвращаемые типы с универсальными"
            ],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 120383234,
                     helpText: "Да. Вы также можете комбинировать непрозрачные возвращаемые типы с универсальными."),
            
            Question(question: [
                "Выберете корректный вариант возвращаемого непрозрачного типа"
            ],
                     image: "",
                     optionA: "func one() -> some Shape",
                     optionB: "func two() -> T<Shape>",
                     optionC: "func three() -> opaque Shape",
                     optionD: "",
                     id: 327968656,
                     helpText: "func one() -> some Shape. К возвращаемому типу добавляется ключевое слово some."),
            
            Question(question: [
                "Должны ли все возможные возвращаемые значения иметь один и тот же тип, если функция с возвращаемым непрозрачным типом возвращается из нескольких мест?"
            ],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 868235133,
                     helpText: """
                     Да. Если функция с возвращаемым непрозрачным типом возвращается из нескольких мест, все возможные возвращаемые значения должны иметь один и тот же тип.
                     
                     Для универсальной функции этот возвращаемый тип может использовать параметры универсального типа функции, но он все равно должен быть одного типа.
                     """),
            
            Question(question: [
                "Сможете ли вы использовать универсальный шаблон в непрозрачном возвращаемом типе?"
            ],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 767936058,
                     helpText: "Да. Требование всегда возвращать один тип не мешает вам использовать универсальные шаблоны в непрозрачном возвращаемом типе."),
            
            Question(question: [
                "Эта функция скомпилируется и отработает без ошибок?"
            ],
                     image: "Opaque01",
                     optionA: "Да",
                     optionB: "Вызовет ошибку компиляции",
                     optionC: "",
                     optionD: "",
                     id: 448533145,
                     helpText: """
                     Да. Требование всегда возвращать один тип не мешает вам использовать универсальные шаблоны в непрозрачном возвращаемом типе. Вот пример функции, которая включает параметр типа в базовый тип возвращаемого значения.
                     
                     В этом случае базовый тип возвращаемого значения зависит от T: какая бы фигура ни была передана, repeat(shape: count :) создает и возвращает массив этой формы.
                     
                     Тем не менее, возвращаемое значение всегда имеет один и тот же базовый тип [T], поэтому следует требование, чтобы функции с непрозрачными типами возврата должны возвращать значения только одного типа.
                     """),
            
            Question(question: [
                "Возврат непрозрачного типа очень похож на использование типа протокола в качестве типа возвращаемого значения функции, но эти два вида возвращаемого типа различаются этим"
            ],
                     image: "",
                     optionA: "Разная работа с идентичностью типа",
                     optionB: "Разный доступ к базовому типу",
                     optionC: "Гибкостью базовых типов",
                     optionD: "",
                     id: 283468548,
                     helpText: """
                     Разная работа с идентичностью типа. Возврат непрозрачного типа очень похож на использование типа протокола в качестве типа возвращаемого значения функции, но эти два вида возвращаемого типа различаются тем, что по-разному работают с идентичностью типа.
                     
                     Непрозрачный тип относится к одному конкретному типу, хотя вызывающая функция не может видеть конкретно что это за тип. Тип протокола может относиться к любому типу, который соответствует протоколу.
                     
                     Вообще говоря, типы протоколов дают вам больше гибкости в отношении базовых типов значений, которые они хранят, а непрозрачные типы позволяют вам делать более строгие гарантии в отношении этих базовых типов.
                     """),
        ]
    }
}
