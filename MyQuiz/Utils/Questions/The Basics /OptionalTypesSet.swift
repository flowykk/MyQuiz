//
//  OptionalTypesSet.swift
//  Swifty-Quiz
//
//  Created by Евгений Никитин on 04.07.2021.
//  Copyright © 2021 Evel-Devel. All rights reserved.
//

import Foundation

final class OptionalTypesSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Мы используем двойной вопросительный знак ?? именно для этого"],
                     image: "",
                     optionA: "Предоставить дефолтное значение",
                     optionB: "Принудительное извлечение",
                     optionC: "Сделать переменную опциональной",
                     optionD: "",
                     id: 240633108,
                     helpText: """
                     Предоставить дефолтное значение. Оператор объединения по nil (a ?? b) извлекает опционал a, если он содержит значение, или возвращает любое дефолтное значение b (которое вы укажете), если a равно nil.
                     
                     Выражение a может быть только опционалом.
                     Выражение b должно быть такого же типа, что и значение внутри a.
                     """),
            
            Question(question: ["Выберите \"опциональный Bool\""],
                     image: "",
                     optionA: "Bool?",
                     optionB: "Bool",
                     optionC: "true?",
                     optionD: "",
                     id: 368086669,
                     helpText: "Bool?."),
            
            Question(question: ["Можно ли использовать переменную с явным, не опциональным типом данных, до ее инициализации?",
                                "Есть переменная с явным, не опциональным типом данных, можете ли вы использовать ее до инициализации?",
                                "Можно ли использовать переменную до инициализации, если она не является опционалом?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 156740503,
                     helpText: "Нет. Использование переменной или константы до ее инициализации в Swift невозможно (кроме значений с опциональными типами)."),
            
            Question(question: ["Каким образом мы можем установить опциональную переменную в состояние отсутствия значения?",
                                "Каким путем вы можете присвоить опциональной переменной отсутствующее значение?",
                                "Отсутствующее значение для опциональной переменной можно установить именно так"],
                     image: "",
                     optionA: "Присвоить nil",
                     optionB: "Присвоить 0",
                     optionC: "Присвоить литерал пустого массива",
                     optionD: ".removeValue",
                     id: 911230345,
                     helpText: """
                     Присвоить nil. Мы можем установить опциональную переменную в состояние отсутствия значения, путем присвоения ему специального значения nil. nil не может быть использован с не опциональными константами и переменными.
                     
                     Если значение константы или переменной при определенных условиях в коде должно когда-нибудь отсутствовать, всегда объявляйте их как опциональное значение соответствующего типа.
                     """),
            
            Question(question: ["Каким образом мы можем проверить, содержит ли опционал значение?",
                                "Как мы можем узнать, содержит опционал значение или нет?",
                                "Таким образом вы можете узнать, содержит опционал значение или нет"],
                     image: "",
                     optionA: "Сравнивая с nil через if",
                     optionB: "Через оператор ===",
                     optionC: "Внутри цикла for-in",
                     optionD: "Через forced unwrap",
                     id: 575266688,
                     helpText: """
                     Сравнивая с nil через if. Вы можете использовать инструкцию if, сравнивая опционал с nil, чтобы проверить, содержит ли опционал значение.
                     
                     Это сравнение можно сделать с помощью оператора «равенства» (==) или оператора «неравенства» (!=). Если опционал имеет значение, он будет рассматриваться как «неравным» nil.
                     """),
            
            Question(question: ["Если мы точно уверены, что опционал имеет значение, каким наиболее быстрым образом мы можем его получить?",
                                "Каким самым быстрым образом мы можем получить значение опционала, если уверены, что оно присутствует?",
                                "Как быстро получить значение опционала, если значение точно есть?"],
                     image: "",
                     optionA: "Принудительное извлечение (!)",
                     optionB: "Внутри цикла while",
                     optionC: "Привязка опционалов",
                     optionD: "Оператор ??",
                     id: 615093732,
                     helpText: """
                     Принудительное извлечение (!). Если вы уверены, что опционал содержит значение, вы можете получить доступ к его значению, добавив восклицательный знак (!) в конце имени опционала.
                     
                     Восклицательный знак фактически говорит: «Я знаю точно, что этот опционал содержит значение, пожалуйста, используй его». Это выражение известно как Принудительное извлечение значения опционала.
                     """),
            
            Question(question: ["Как называется принудительное извлечение опционального значения?",
                                "Извлечение опционального значения с помощью оператора (!)"],
                     image: "",
                     optionA: "Force unwrap",
                     optionB: "Unwrapping",
                     optionC: "Optional Chaining",
                     optionD: "",
                     id: 458422941,
                     helpText: """
                     Force unwrap. Swift предлагает механизм извлечения опционального значения, который называется принудительным извлечением.
                     
                     При этом с помощью специального оператора значение опционального типа данных преобразуется в значение основного (для этого опционала) типа данных, например Int? преобразуется в Int. Для принудительного извлечения используется знак восклицания в качестве постфикса названия параметра, содержащего значение опционального типа.
                     
                     При принудительном извлечении значения вы должны гарантировать, что параметр с опциональным типом данных содержит какое-либо значение, а не равен nil. В противном случае будет иметь место попытка преобразовать в основной тип данных несуществующее значение, после компиляции такого кода мы столкнемся с ошибкой.
                     """),
            
            Question(question: ["Можем ли мы передать опциональный String куску кода, который ожидает неопциональный String?",
                                "Можете ли вы передать опциональный тип Double куску кода, который ждет неопциональный тип Double?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 367846471,
                     helpText: """
                     Нет. Swift - язык типобезопасный, что означает, что Swift помогает вам понять, с какими типами значений ваш код может работать.
                     
                     Если кусок вашего кода ожидает String, безопасность типов не даст вам передать ему Int по ошибке. Кроме того, безопасность типов не позволит вам случайно передать опциональный String куску кода, который ожидает неопциональный String.
                     
                     Безопасность типов позволяет вам улавливать и исправлять ошибки как можно раньше в процессе разработки.
                     """),
            
            Question(question: ["Можем ли мы использовать значение с типом Int? (опциональный) как операнд в математической операции?",
                                "Можете ли вы использовать Double? (опциональный) как операнд в математической операции?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 160114527,
                     helpText: """
                     Нет. Запомните, опциональный тип данных - это совершенно новый тип данных, поэтому, несмотря на то, что опционалы могут принимать значения основных типов данных, остальные свойства этих типов к опционалам не относятся.
                     
                     Например вы не можете использовать типы Int? или Double? при выполнении математических операций.
                     """),
            
            Question(question: ["Какой тип Swift присвоит константе convertedNum?",
                                "Константе convertedNum присвоится именно этот тип",
                                "Swift присвоит этот тип константе convertedNum"],
                     image: "TheBasics57",
                     optionA: "Int?",
                     optionB: "Int",
                     optionC: "String",
                     optionD: "Столкнемся с ошибкой",
                     id: 977608778,
                     helpText: """
                     Int?. Поскольку метод Int() может иметь недопустимый аргумент, он возвращает опциональный Int, вместо Int.
                     
                     Опциональный Int записывается как Int?, а не Int. Знак вопроса означает, что содержащееся в ней значение является опциональным, что означает, что он может содержать некое Int значение, или он может вообще не содержать никакого значения.
                     
                     Он не может содержать ничего другого, например, Bool значение или значение String. Он либо Int, либо вообще ничто.
                     """),
            
            Question(question: ["Какое значение будет присвоено константе colorToUse?",
                                "Какое значение получит colorToUse?"],
                     image: "BasicOperators31",
                     optionA: "yellow",
                     optionB: "Значение colorSetByUser",
                     optionC: "Столкнемся с ошибкой",
                     optionD: "nil",
                     id: 360577721,
                     helpText: """
                     yellow. Переменная colorSetByUser объявлена как строковый (String) опционал и по умолчанию равна nil. Так как colorSetByUser является опционалом, ее значение можно анализировать посредством оператора объединения по nil.
                     
                     В вышеприведенном примере этот оператор задает начальное значение для строковой (String) переменной colorToUse.
                     
                     Так как colorSetByUser равно nil, выражение colorSetByUser ?? defaultColor возвратит значение defaultColor, т.е. если переменной colorSetByUser присвоить отличное от nil значение и снова передать ее в оператор объединения по nil, вместо значения по умолчанию будет использовано значение внутри colorSetByUser.
                     """),
            
            Question(question: ["Какое значение присвоится константе test, если мы пройдем компиляцию?",
                                "Если константе test будет присвоено значение, каким оно будет?",
                                "Каким значение получит константа test?"],
                     image: "BasicOperators32",
                     optionA: "К",
                     optionB: "nil",
                     optionC: "Столкнемся с ошибкой",
                     optionD: "Никакое",
                     id: 781371255,
                     helpText: """
                     К. Оператор объединения по nil (a ?? b) извлекает опционал a, если он содержит значение, или возвращает значение по умолчанию b, если a равно nil.
                     
                     Выражение a может быть только опционалом. Выражение b должно быть такого же типа, что и значение внутри a.
                     
                     В данном примере, переменной character, с неявным объявлением типа, присваивается тип String по умолчанию, значит типы равны и константе test будет присвоено значение K.
                     """),
            
            Question(question: ["Выберите вариант, где корректно используется привязка опционалов"],
                     image: "",
                     optionA: "if let one = two {}",
                     optionB: "if var one == two {}",
                     optionC: "guard let one = two",
                     optionD: "",
                     id: 223220392,
                     helpText: """
                     if let one = two {}. Можно использовать Привязку опционалов, чтобы выяснить содержит ли опционал значение, и если да, то сделать это значение доступным в качестве временной константы или переменной.
                     
                     Привязка опционалов может использоваться с инструкциями if и while, для проверки значения внутри опционала, и извлечения этого значения в константу или переменную, в рамках одного действия.
                     """),
            
            Question(question: ["Можем ли мы использовать и переменные и константы при привязке опционалов?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 194309225,
                     helpText: "Да. Вы можете использовать и константы и переменные для привязки опционалов."),
            
            Question(question: ["Можем ли мы использовать несколько опциональных привязок и логических условий подряд, написав их через запятую?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 390653238,
                     helpText: """
                     Да. Вы можете включать столько опциональных привязок и логических условий в единственную инструкцию if, сколько вам требуется, разделяя их запятыми.
                     
                     Если какое-то значение в опциональной привязке равно nil, или любое логическое условие вычисляется как false, то все условия выражения будет считаться false.
                     """),
            
            Question(question: ["Если мы написали несколько опциональных привязок и логических условий через запятую, и одно из этих условий окажется false, что мы получим после выполнения всего выражения?"],
                     image: "",
                     optionA: "false",
                     optionB: "true",
                     optionC: "Ничего",
                     optionD: "",
                     id: 566543282,
                     helpText: "false. Если какое-то значение в опциональной привязке равно nil, или любое логическое условие вычисляется как false, то все условия выражения будет считаться false."),
            
            Question(question: ["Что из этого списка будет являться неявно извлеченным опционалом?"],
                     image: "",
                     optionA: "String!",
                     optionB: "String?",
                     optionC: "String",
                     optionD: "",
                     id: 411037999,
                     helpText: """
                     String!. Иногда, сразу понятно из структуры программы, что опционал всегда будет иметь значение, после того как это значение впервые было установлено.
                     
                     В этих случаях, очень полезно избавиться от проверки и извлечения значения опционала каждый раз при обращении к нему, потому что можно с уверенностью утверждать, что он постоянно имеет значение. Эти виды опционалов называются неявно извлеченные опционалы.
                     
                     Их можно писать, используя восклицательный знак (String!), вместо вопросительного знака (String?), после типа, который вы хотите сделать опциональным.
                     """),
            
            Question(question: ["Что мы получим, когда попытаемся получить доступ к неявно извлеченному опционалу, когда он не содержит значения?"],
                     image: "",
                     optionA: "Runtime error",
                     optionB: "Ошибку компиляции",
                     optionC: "Предупреждение",
                     optionD: "",
                     id: 237032304,
                     helpText: """
                     Runtime error. Если вы попытаетесь получить доступ к неявно извлеченному опционалу когда он не содержит значения - вы получите runtime ошибку.
                     
                     Результат будет абсолютно тот же, если бы вы разместили восклицательный знак после нормального опционала, который не содержит значения.
                     """),
            
            Question(question: ["Если во время привязки опционала вы создаете константу, а проверяемое значение является классом, можете ли вы менять наследуемые переменные этого класса для этой константы?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 512713774,
                     helpText: """
                     Да. Так как класс является ссылочным типом, даже когда вы присваиваете его константе - вы можете менять родительские свойства, если они записаны как переменные (var).
                     
                     Если через привязку опционалов вы проверяете структуру, то ее значение будет скопировано, и изменить свойства этой константы вы не сможете.
                     """),
            
            Question(question: [
                "Можем ли мы так разворачивать self?"
            ],
                     image: "ARC05",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 875501741,
                     links: [
                        "https://digitalbunker.dev/updating-if-guard-let-for-swift-5-7/",
                        "https://www.swiftbysundell.com/articles/swifts-new-shorthand-optional-unwrapping-syntax/"
                     ],
                     helpText: """
                     Да. После Swift 5.7 вы можете использовать такой синтаксис, без указания дополнительных = self (как и в любых других, подобных случаях, не только с self).
                     
                     Такой же принцип работы и с выражением if let, теперь не обязательно писать = значение.
                     """
                    ),
            
            Question(question: [
                "Является ли данный способ развернуть опционал валидным?"
            ],
                     image: "Optionals01",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "Иногда",
                     optionD: "",
                     id: 790037974,
                     links: [
                        "https://www.swiftbysundell.com/articles/swifts-new-shorthand-optional-unwrapping-syntax/",
                        "https://digitalbunker.dev/updating-if-guard-let-for-swift-5-7/"
                     ],
                     helpText: """
                     Да. После Swift 5.7 вы можете использовать подобный синтаксис разворачивания опционалов, без указания дополнительных операторов и исходных значений.
                     
                     Например:
                     guard let title, let body, let recipient else {
                        return false
                     }
                     """
                    ),
        ]
    }
}
