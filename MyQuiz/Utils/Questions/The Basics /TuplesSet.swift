//
//  TuplesSet.swift
//  Swifty-Quiz
//
//  Created by Евгений Никитин on 04.07.2021.
//  Copyright © 2021 Evel-Devel. All rights reserved.
//

import Foundation

final class TuplesSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Должны ли элементы внутри кортежа быть одного и того же типа?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 832713231,
                     helpText: "Нет. Кортежи группируют несколько значений в одно составное значение. Значения внутри кортежа могут быть любого типа, то есть, нет необходимости, чтобы они были одного и того же типа."),
            
            Question(question: ["Могут ли элементы в кортеже распологаться в произвольном порядке?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 198307475,
                     helpText: "Да. Вы можете создать кортеж с любой расстановкой типов, и они могут содержать сколько угодно нужных вам типов. Ничто вам не мешает иметь кортеж типа (Int, Int, Int), или типа (String, Bool), или же с любой другой расстановкой типов по вашему желанию."),
            
            Question(question: ["Если мы добавили в кортеж сначала целое число, а потом строковое значение, какой тип кортежа у нас получится?"],
                     image: "",
                     optionA: "(Int, String)",
                     optionB: "(String, Int)",
                     optionC: "(Int, Character)",
                     optionD: "",
                     id: 790787982,
                     helpText: "(Int, String). Если мы группируем вместе два отдельных значения Int и String, это может быть описано как \"кортеж типа (Int, String)\"."),
            
            Question(question: ["Как мы можем \"игнорировать\" некоторые элементы массива?"],
                     image: "",
                     optionA: "С помощью символа подчеркивания _",
                     optionB: "С помощью символа звездочки *",
                     optionC: "Не писать имя ненужного элемента",
                     optionD: "",
                     id: 767061987,
                     helpText: "С помощью символа подчеркивания _. Если вам нужны только некоторые из значений кортежа, вы можете игнорировать части кортежа во время разложения с помощью символа подчеркивания (_)"),
            
            Question(question: ["Мы можем обращаться к элементам кортежа, как?"],
                     image: "",
                     optionA: "Через числовые индексы",
                     optionB: "Через сабскрипты",
                     optionC: "По ключу",
                     optionD: "",
                     id: 670017582,
                     helpText: "Через числовые индексы. Можно получать доступ к отдельным частям кортежа, используя числовые индексы, начинающиеся с нуля."),
            
            Question(question: ["Можете ли вы обратиться к элементу кортежа по имени, которое присвоили ранее, при объявлении?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 955455333,
                     helpText: "Да. Когда вы присвоили имя элементу кортежа, вы можете обращаться к нему по имени."),
            
            Question(question: ["Мы можем обратиться к первому элементу кортежа через числовой индекс, как именно?",
                                "Как корректно обратиться в первому элементу кортежа?",
                                "Каким образом мы можем обратиться к первому элементу кортежа?"],
                     image: "",
                     optionA: "someTuple.0",
                     optionB: "someTuple.1",
                     optionC: "someTuple[0]",
                     optionD: "someTuple(1)",
                     id: 718740639,
                     helpText: """
                     someTuple 0. Вы можете разложить содержимое кортежа на отдельные константы и переменные, к которым можно получить доступ привычным способом.
                     
                     Если вам нужны только некоторые из значений кортежа, вы можете игнорировать части кортежа во время разложения с помощью символа подчеркивания (_).
                     
                     В качестве альтернативы можно получать доступ к отдельным частям кортежа, используя числовые индексы, начинающиеся с нуля.
                     """),
            
            Question(question: ["В какой момент мы можем дать имена отдельным элементам кортежа?",
                                "Когда мы можем дать имена отдельным элементам кортежа?"],
                     image: "",
                     optionA: "При объявлении",
                     optionB: "После инициализации",
                     optionC: "После первого использования",
                     optionD: "В момент обращения к элементу",
                     id: 715187356,
                     helpText: "При объявлении. Вы можете давать имена отдельным элементам кортежа во время объявления. Например: let gameRecord = (questionNumber: 50, score: 49)."),
            
            Question(question: ["Обязан ли порядок указания имен типов соответствовать порядку следования элементов в кортеже?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "Да, если кортеж - константа",
                     optionD: "",
                     id: 831959068,
                     helpText: """
                     Да. Тип данных кортежа — это фиксированная упорядоченная последовательность имен типов данных элементов кортежа.
                     
                     Тип данных обрамляется в круглые скобки, а имена типов элементов отделяются друг от друга запятыми. Порядок указания имен типов обязательно должен соответствовать порядку следования элементов в кортеже.
                     """),
            
            Question(question: ["Какой тип будет у данного кортежа?",
                                "У этого кортежа будет такой тип данных",
                                "Какой тип данных будет присвоен этому кортежу?"],
                     image: "TheBasics69",
                     optionA: "(String, Double, Bool)",
                     optionB: "Tuple.type",
                     optionC: "(String, Float, Bool)",
                     optionD: "(Character, Double, True)",
                     id: 589010536,
                     helpText: """
                     (String, Double, Bool. У вас мог возникнуть вопрос: если кортеж группирует значения различных типов данных в одно, то какой же тогда тип данных у самого кортежа? Правильный ответ: (String, Double, Bool).
                     
                     Тип данных кортежа - это фиксированный упорядоченный набор типов данных, входящих в него значений, который записывается в скобках и элементы которого отделяются запятыми друг от друга. Для кортежа из нашего примера это (String, Double, Bool) и у нас он задается неявно.
                     
                     Порядок указания типов данных должен соответствовать порядку следования элементов в кортеже.
                     """),
            
            Question(question: ["Можем ли мы задать имя для каждого элемента кортежа отдельно?",
                                "Мы не можем задать имена для части элементов кортежа, мы обязаны либо не использовать их вовсе, либо задать их для каждого элемента. Так ли это?",
                                "Присвоение элементам кортежа имен не лишает нас возможности использовать их индексы. Так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 349115073,
                     helpText: """
                     Да. Для каждого элемента кортежа можно задать не только значение, но и имя. Имя элемента указывается отдельно перед каждым элементом через двоеточие.
                     
                     При этом задать имена для отдельных элементов невозможно: вы должны либо указать имена для всех элементов, либо не использовать их вовсе. Указанные имена кортежа можно использовать при получении значений этих элементов.
                     
                     При этом применяется тот же синтаксис, что и при доступе через индексы. Присвоение имен значениям не лишает вас возможности использовать индексы. Индексы в кортеже можно задействовать всегда. Доступ к элементам с использованием имен удобнее и нагляднее, чем доступ через индексы.
                     """),
            
            Question(question: ["Можете ли вы сравнивать кортежи между собой?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 885757031,
                     helpText: """
                     Да. Сравнение кортежей производится последовательным сравнением элементов кортежей: сперва сравниваются первые элементы обоих кортежей; если они идентичны, то производится сравнение следующих элементов, и так далее до тех пор, пока не будут обнаружены неидентичные элементы.
                     
                     Встроенные механизмы Swift позволяют сравнивать кортежи с количеством элементов менее 7. При необходимости сравнения кортежей с бóльшим количеством элементов вам необходимо реализовать собственные механизмы.
                     
                     Данное ограничение в Apple ввели не от лени: если ваш кортеж имеет большое количество элементов, то есть повод задуматься о том, чтобы заменить его структурой или классом.
                     """),
            
            Question(question: ["Можем ли мы выполнить подобную итерацию по кортежу целых чисел?"],
                     image: "ControlFlow06",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 549541537,
                     helpText: "Нет. Мы не сможем выполнить итерацию по кортежу, кортеж не поддерживает протокол Sequence, и мы получим следующую ошибку компиляции: For-in loop requires '(Int, Int, Int)' to conform to 'Sequence'."),
            
            
            Question(question: ["Какой результат вернет выражение (1, \"alpha\") < (2, \"beta\")?",
                                "Какой результат вернет выражение (4, \"beta\") < (4, \"gamma\")?",
                                "Какой результат вернет выражение (3.14, \"pi\") == (3.14, \"pi\")?"],
                     image: "",
                     optionA: "true",
                     optionB: "false",
                     optionC: "Столкнемся с ошибкой",
                     optionD: "",
                     id: 105622491,
                     helpText: """
                     true. Пример №1 - (1, \"alpha\") < (2, \"beta\") вернет true (истина), так как 1 меньше 2, вторая пара элементов не учитывается.
                     
                     Пример №2 - (4, \"beta\") < (4, \"gamma\") вернет true (истина), так как \"beta\" меньше \"gamma\".
                     
                     Пример №3 - (3.14, \"pi\") == (3.14, \"pi\") вернет true (истина), так как все соответствующие элементы идентичны.
                     """),
            
            Question(question: ["Если левая часть выражения является кортежем с несколькими значениями, можем ли мы присвоить сразу несколько констант или переменных его значениям?",
                                "Левая часть выражения, это кортеж, можем ли мы присвоить несколько констант или переменных всем его значениям",
                                "Можем ли мы сразу присвоить несколько констант или переменных значениям кортежа?"],
                     image: "",
                     optionA: "Можем, через запятую: (x, y) = (1, 2)",
                     optionB: "Можем, через точку с запятой",
                     optionC: "Нет, не можем",
                     optionD: "Можем, через слеш: (x, y) = 1 / 2",
                     id: 238686527,
                     helpText: "Можем, через запятую: (x, y) = (1, 2). Если левая часть выражения является кортежем с несколькими значениями, его элементам можно присвоить сразу несколько констант или переменных. let (x, y) = (1, 2), где x равно 1, а y равно 2."),
            
            Question(question: ["Можно ли сравнивать между собой два кортежа с типом (String, Int)?",
                                "У вас есть два кортежа с типом (String, Int), можно ли их сравнить?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Только != или ==",
                     optionC: "Только < или >",
                     optionD: "Нет",
                     id: 936185458,
                     helpText: """
                     Да. Вы можете сравнивать кортежи, которые имеют одно и то же количество значений, которые, в свою очередь, должны быть сравниваемыми, что означает, что кортеж типа (Int, String) может быть сравнен с кортежем такого же типа.
                     
                     Кортежи сравниваются слева направо по одному значению за раз до тех пор, пока операция сравнения не найдет отличия между значениями. Если все значения кортежей попарно равны, то и кортежи так же считаются равными.
                     
                     Кортежи могут сравниваться, только в том случае, если оператор сравнения можно применить ко всем членам кортежей соответственно.
                     """),
            
            Question(question: ["Можно ли сравнивать между собой два кортежа с типом (String, Bool)?",
                                "У вас есть два кортежа с типом (String, Bool), можно ли их сравнить?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Только != или ==",
                     optionC: "Да",
                     optionD: "Только < или >",
                     id: 171205666,
                     helpText: """
                     Нет. Кортежи могут сравниваться только в том случае, если оператор сравнения можно применить ко всем членам кортежей соответственно.
                     
                     Например, вы можете сравнить два кортежа типа (String, Int) потому что и String, и Int могут сравниваться операторами сравнения.
                     
                     Кортеж типа (String, Bool) сравниваться не может, так как к значениям типа Bool операторы сравнения не применяются.
                     """),
        ]
    }
}
