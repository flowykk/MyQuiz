
//  Created by Евгений Никитин on 25.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

final class StructuralPatternsSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Что лежит в основе структурных паттернов?"],
                     image: "",
                     optionA: "Структурирование кода",
                     optionB: "Управление поведением",
                     optionC: "Создание объектов",
                     optionD: "",
                     id: 978104987,
                     helpText: "Структурирование кода. Структурные паттерны позволяют лучше структурировать код, чтобы его было легче понимать."),
            
            Question(question: ["Структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе",
                                "Какой структурный паттерн проектирования позволяет объектам с несовместимыми интерфейсами работать вместе?"],
                     image: "",
                     optionA: "Адаптер",
                     optionB: "Мост",
                     optionC: "Компоновщик",
                     optionD: "Декоратор",
                     id: 805242242,
                     helpText: "Адаптер. Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе."),
            
            Question(question: ["Целью какого паттерна является минимизация используемой памяти там, где необязательно создавать несколько объектов, а вместо этого можно переиспользовать один?",
                                "Структурный паттерн, целью которого является минимизация используемой памяти там, где необязательно создавать несколько объектов, а можно переиспользовать один",
                                "Какой паттерн позволяет переиспользовать один объект, чтобы не создавать новые?"],
                     image: "",
                     optionA: "Flyweight",
                     optionB: "Delegate",
                     optionC: "Adapter",
                     optionD: "",
                     id: 567890597,
                     helpText: "Паттерн flyweight — «легковес». В переводах классических книг он обычно называется «приспособленец». По классификации это структурный паттерн. Его цель — в минимизации используемой памяти там, где необязательно создавать несколько объектов, а вместо этого можно переиспользовать один."),
            
            Question(question: ["Структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга",
                                "Назовите паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга"],
                     image: "",
                     optionA: "Мост",
                     optionB: "Компоновщик",
                     optionC: "Декоратор",
                     optionD: "Легковес",
                     id: 810805847,
                     helpText: "Мост. Мост — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга."),
            
            Question(question: ["Структурный шаблон, который берет сложную систему и упрощает ее, предоставляя простой интерфейс",
                                "Паттерн, который упрощает сложную систему, предоставляя простой интерфейс",
                                "Этот структурный паттерн предоставляет простой интерфейс от упрощенной сложной системы"],
                     image: "",
                     optionA: "Facade (Фасад)",
                     optionB: "Memento (Хранитель)",
                     optionC: "Delegate (Делегат)",
                     optionD: "",
                     id: 242101429,
                     helpText: "Facade (Фасад). Паттерн Facade (фасад) — структурный шаблон проектирования. Он предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку."),
            
            Question(question: ["Какой паттерн можно применить, когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения?",
                                "Какой паттерн можно применить, когда нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причем расширить суперкласс вы не можете?"],
                     image: "",
                     optionA: "Adapter",
                     optionB: "Bridge",
                     optionC: "Decorator",
                     optionD: "",
                     id: 756324106,
                     helpText: "Adapter. Адаптер (adapter) позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу. Можно поместить недостающую функциональность в адаптер и приспособить его для работы с суперклассом. Такой адаптер может работать со всеми подклассами иерархии."),
            
            Question(question: ["Есть ли у паттерна Facade (Фасад) строгие предписания того, как его реализовывать?",
                                "У паттерна Facade (Фасад) есть жесткие предписания того, какие методы должны использоваться при его реализации?",
                                "Чтобы максимально удобно структурировать работу нескольких сложных систем используется паттерн Facade (Фасад), есть ли у него строгие предписания по реализации?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 858837900,
                     helpText: "Нет. У паттерна Facade (Фасад) паттерна нет строгих предписаний о том, как реализовывать фасад, какие у него должны быть методы. К каждой задаче фасад делается так, чтобы максимально удобно структурировать сложную работу нескольких систем."),
            
            Question(question: ["Какой паттерн можно использовать, когда вы хотите разделить монолитный класс, который содержит несколько различных реализаций какой-то функциональности (например, если класс может работать с разными системами баз данных)?"],
                     image: "",
                     optionA: "Bridge",
                     optionB: "Adapter",
                     optionC: "Composite",
                     optionD: "",
                     id: 357878914,
                     helpText: """
                     Bridge. Чем больше класс, тем тяжелее разобраться в его коде, и тем больше это затягивает разработку.
                     
                     Кроме того, изменения, вносимые в одну из реализаций, приводят к редактированию всего класса, что может привести к внесению случайных ошибок в код. Мост (Bridge) позволяет разделить монолитный класс на несколько отдельных иерархий.
                     
                     После этого вы можете менять их код независимо друг от друга. Это упрощает работу над кодом и уменьшает вероятность внесения ошибок.
                     """),
            
            Question(question: ["Назовите паттерн, чьим принципом является следующее: вместо создания и хранения в памяти нескольких объектов, мы создаем и храним один объект и используем его для всех случаев",
                                "Создание одного объекта и использование его для всех необходимых случаев, является принципом данного паттерна"],
                     image: "",
                     optionA: "Flyweight",
                     optionB: "Delegate",
                     optionC: "Adapter",
                     optionD: "Abstract Factory",
                     id: 147233158,
                     helpText: "Flyweight. Вместо создания и хранения в памяти нескольких объектов, нужных для одной цели, мы создаем и храним один объект и используем его для всех случаев. Все стандартные цвета, такие как UIColor.red, UIColor.green, UIColor.white, UIColor.black и т. д. реализованы по паттерну flyweight."),
            
            Question(question: ["К какому паттерну относятся данные плюсы: позволяет строить платформо-независимые программы, скрывает лишние или опасные детали реализации от клиентского кода?"],
                     image: "",
                     optionA: "Мост",
                     optionB: "Компоновщик",
                     optionC: "Заместитель",
                     optionD: "",
                     id: 381669616,
                     helpText: "Мост. Преимущества паттерна Мост: Позволяет строить платформо-независимые программы. Скрывает лишние или опасные детали реализации от клиентского кода. Реализует принцип открытости/закрытости."),
            
            Question(question: ["Можем ли мы использовать Фасад (Facade) как объект одиночку (Singleton)?",
                                "Можно ли использовать паттерн Facade как класс-одиночку (Singleton)?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 598574838,
                     helpText: "Да. Фасад можно сделать Одиночкой, так как обычно нужен только один объект-фасад."),
            
            Question(question: ["Структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект",
                                "Какой структурный паттерн проектирования позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект?"],
                     image: "",
                     optionA: "Компоновщик",
                     optionB: "Мост",
                     optionC: "Заместитель",
                     optionD: "",
                     id: 221373135,
                     helpText: "Компоновщик. Компоновщик — это структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект."),
            
            Question(question: ["Какому паттерну присущи следующие преимущества: позволяет контролировать сервисный объект незаметно для клиента, может работать, даже если сервисный объект еще не создан?",
                                "К какому паттерну относятся данные преимущества: может работать, даже если сервисный объект еще не создан, может контролировать жизненный цикл служебного объекта?"],
                     image: "",
                     optionA: "Proxy",
                     optionB: "Decorator",
                     optionC: "Composite",
                     optionD: "Mediator",
                     id: 913280128,
                     helpText: "Proxy. Преимущества и недостатки паттерна Proxy (прокси, заместитель): Позволяет контролировать сервисный объект незаметно для клиента. Может работать, даже если сервисный объект еще не создан. Может контролировать жизненный цикл служебного объекта. Усложняет код программы из-за введения дополнительных классов. Увеличивает время отклика от сервиса."),
            
            Question(question: ["Структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки»",
                                "Какой паттерн проектирования позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки»?"],
                     image: "",
                     optionA: "Декоратор",
                     optionB: "Компоновщик",
                     optionC: "Фасад",
                     optionD: "",
                     id: 236634056,
                     helpText: "Декоратор. Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки»."),
            
            Question(question: ["Дизайнер придумал для вашего приложения цветовую палитру, с помощью какого паттерна ее логичнее всего хранить и использовать?",
                                "Каким паттерном логичнее всего пользоваться, если вам нужно хранить и использовать цветовую палитру, которая будет использоваться для вашего приложения?",
                                "Дизайнер придумал для вашего приложения палитру брендовых цветов, какой паттерн логичнее всего применить для хранения этих цветов, и их использования?"],
                     image: "",
                     optionA: "Flyweight",
                     optionB: "Composite",
                     optionC: "Adapter",
                     optionD: "",
                     id: 475144163,
                     helpText: """
                     Flyweight. В любом приложении под iOS используются цвета. Как правило, дизайнер придумывает палитру из оттенков, наиболее часто используемых в дизайне приложения, а в коде хранятся переменные, которые эту палитру описывают.
                     
                     Самым логичным решением будет хранить эти переменные, используя паттерн flyweight, который в Swift реализуется очень просто (помимо очевидного хранения цветов внутри Color Set в Assets).
                     """),
            
            Question(question: ["Какой паттерн можно использовать, когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует?"],
                     image: "",
                     optionA: "Decorator",
                     optionB: "Facade",
                     optionC: "Flyweight",
                     optionD: "",
                     id: 752709930,
                     helpText: "Decorator. При использовании паттерна Декоратор, объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обернутым."),
            
            Question(question: ["Структурный шаблон проектирования, расширяющий функциональность объекта без использования наследования",
                                "Какой структурный шаблон проектирования расширяет функциональность объекта без использования наследования?",
                                "Этот паттерн, без использования наследования расширяет функциональность объекта"],
                     image: "",
                     optionA: "Decorator",
                     optionB: "Chain Of Responsibility",
                     optionC: "Mediator",
                     optionD: "Command",
                     id: 350360009,
                     helpText: "Decorator. Decorator (декоратор) — структурный шаблон проектирования, расширяющий функциональность объекта без использования наследования."),
            
            Question(question: ["Какой паттерн можно использовать, когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме?",
                                "Какой паттерн можно использовать, когда вы хотите разложить подсистему на отдельные слои?"],
                     image: "",
                     optionA: "Фасад",
                     optionB: "Декоратор",
                     optionC: "Компоновщик",
                     optionD: "",
                     id: 404002309,
                     helpText: """
                     Фасад. Фасад предлагает определённый вид системы по умолчанию, устраивающий большинство клиентов. Используйте фасады для определения точек входа на каждый уровень подсистемы.
                     
                     Если подсистемы зависят друг от друга, то зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.
                     """),
            
            Question(question: ["Этот структурный шаблон проектирования представляет объекты в виде древовидной структуры и обеспечивает к ним доступ через единый интерфейс",
                                "Какой структурный паттерн представляет объекты в виде древовидной структуры?",
                                "Какой паттерн проектирования обеспечивает доступ к древовидной структуре объектов через единый интерфейс?"],
                     image: "",
                     optionA: "Composite",
                     optionB: "Chain Of Responsibility",
                     optionC: "Mediator",
                     optionD: "Command",
                     id: 311158041,
                     helpText: "Composite. Паттерн Composite (компоновщик) — структурный шаблон проектирования. Он представляет объекты в виде древовидной структуры и обеспечивает к ним доступ через единый интерфейс."),
            
            Question(question: ["Какой паттерн можно использовать, когда нельзя расширить обязанности объекта с помощью наследования?",
                                "Какой паттерн поможет расширить обязанности final класса?"],
                     image: "",
                     optionA: "Декоратор",
                     optionB: "Компоновщик",
                     optionC: "Адаптер",
                     optionD: "",
                     id: 170962347,
                     helpText: "Декоратор. Во многих языках программирования есть ключевое слово final, которое может блокировать наследование класса. Расширить такие классы можно только с помощью ."),
            
            Question(question: ["Структурный шаблон проектирования, который представляет собой объект, контролирующий доступ к другому объекту, перехватывая все вызовы.",
                                "Какой паттерн представляет собой объект, контролирующий доступ к другому объекту, перехватывая все вызовы?",
                                "Этот структурный шаблон проектирования представляет собой объект, контролирующий доступ к другому объекту, перехватывая все вызовы"],
                     image: "",
                     optionA: "Proxy",
                     optionB: "Adapter",
                     optionC: "Bridge",
                     optionD: "Facade",
                     id: 258648915,
                     helpText: "Proxy. Паттерн Proxy (прокси, «заместитель») — структурный шаблон проектирования. Представляет собой объект, который контролирует доступ к другому объекту, перехватывая все вызовы. При этом объект-прокси имеет тот же интерфейс, что и настоящий объект."),
            
            Question(question: ["К какому паттерну относится данный недостаток: рискует стать божественным объектом, привязанным ко всем классам программы?"],
                     image: "",
                     optionA: "Facade",
                     optionB: "Composite",
                     optionC: "Mediator",
                     optionD: "",
                     id: 744177559,
                     helpText: "Facade. Этот недостаток относится к паттерну Facade"),
            
            Question(question: ["Какому паттерну присущи следующие преимущества: большая гибкость, чем у наследования, позволяет добавлять обязанности на лету, можно добавлять несколько новых обязанностей сразу?",
                                "К какому паттерну относится это преимущество: позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни, большая гибкость, чем у наследования?",
                                "У какого паттерна большая гибкость, чем у наследования, но есть недостатки в виде трудностей конфигурирования многократно обёрнутых объектов и обилия крошечных классов?"],
                     image: "",
                     optionA: "Decorator",
                     optionB: "Mediator",
                     optionC: "Composite",
                     optionD: "",
                     id: 234079097,
                     helpText: """
                     Decorator. Преимущества и недостатки паттерна Decorator (декоратор): Большая гибкость, чем у наследования. Позволяет добавлять обязанности на лету.
                     
                     Можно добавлять несколько новых обязанностей сразу. Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.
                     
                     Трудно конфигурировать многократно обернутые объекты. Обилие крошечных классов.
                     """),
            
            Question(question: ["Какому паттерну присущи данные преимущества: упрощает архитектуру клиента при работе со сложным деревом компонентов, облегчает добавление новых видов компонентов?",
                                "К какому паттерну относится данный недостаток: создает слишком общий дизайн классов?"],
                     image: "",
                     optionA: "Компоновщик",
                     optionB: "Адаптер",
                     optionC: "Декоратор",
                     optionD: "",
                     id: 69688996,
                     helpText: "Компоновщик. Преимущества и недостатки паттерна Composite (компоновщик): Упрощает архитектуру клиента при работе со сложным деревом компонентов. Облегчает добавление новых видов компонентов. Создает слишком общий дизайн классов."),
            
            Question(question: ["Какой структурный паттерн на изображении?"],
                     image: "StructuralPatterns1",
                     optionA: "Adapter",
                     optionB: "Composite",
                     optionC: "Bridge",
                     optionD: "Decorator",
                     id: 440046098,
                     helpText: "Adapter. Адаптер (Adapter) — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе."),
            
            Question(question: ["Какой паттерн на изображении?"],
                     image: "StructuralPatterns2",
                     optionA: "Bridge",
                     optionB: "Facade",
                     optionC: "Adapter",
                     optionD: "",
                     id: 872534898,
                     helpText: "Bridge. Мост (Bridge) — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга."),
            
            Question(question: ["Какой структурный паттерн здесь изображен?"],
                     image: "StructuralPatterns3",
                     optionA: "Composite",
                     optionB: "Flyweight",
                     optionC: "Proxy",
                     optionD: "",
                     id: 510687068,
                     helpText: "Composite. Компоновщик (Composite) — это структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект."),
            
            Question(question: ["Какой структурный паттерн на изображении?"],
                     image: "StructuralPatterns4",
                     optionA: "Decorator",
                     optionB: "Composite",
                     optionC: "Facade",
                     optionD: "",
                     id: 465982830,
                     helpText: "Decorator. Декоратор (Decorator) — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки»."),
            
            Question(question: ["Какой структурный паттерн на изображении?"],
                     image: "StructuralPatterns5",
                     optionA: "Facade",
                     optionB: "Decorator",
                     optionC: "Composite",
                     optionD: "Flyweight",
                     id: 710302752,
                     helpText: "Facade. Фасад (Facade) — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку."),
            
            Question(question: ["Какой структурный паттерн здесь изображен?"],
                     image: "StructuralPatterns6",
                     optionA: "Flyweight",
                     optionB: "Decorator",
                     optionC: "Facade",
                     optionD: "",
                     id: 875024559,
                     helpText: """
                     Flyweight. Легковес (Flyweight) — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в отведённую оперативную память.
                     
                     Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.
                     """),
            
            Question(question: ["Какой структурный паттерн изображен на картинке?"],
                     image: "StructuralPatterns7",
                     optionA: "Proxy",
                     optionB: "State",
                     optionC: "Facade",
                     optionD: "",
                     id: 383688712,
                     helpText: """
                     Proxy. Заместитель (Proxy) — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители.
                     
                     Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.
                     """)
        ]
    }
}
