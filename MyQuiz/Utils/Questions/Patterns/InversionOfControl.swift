//
//  InversionOfControl.swift
//  Swifty-Quiz
//
//  Created by Евгений Никитин on 20.03.2022.
//  Copyright © 2022 Evel-Devel. All rights reserved.
//

import Foundation

final class InversionOfControl {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Что представляет из себя Инверсия управления?",
                                "Инверсия управления это - ... ?"],
                     image: "",
                     optionA: "Паттерн проектирования",
                     optionB: "Зависимость",
                     optionC: "Open source библиотека",
                     optionD: "Нативный метод в Swift",
                     id: 419675819,
                     helpText: """
                     Паттерн проектирования. Инверсия управления — это паттерн проектирования, позволяющий инвертировать поток управления.
                     
                     Для этого вы выносите все обязанности класса, кроме его основной, наружу, делая их его зависимостями.
                     
                     Благодаря абстракции (использованию протоколов) вы делаете зависимости легко взаимозаменяемыми.
                     """),
            
            Question(question: ["Применение Инверсии управления требует использования протоколов?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 665317739,
                     helpText: """
                     Да. Инверсия управления — это шаблон проектирования (паттерн), позволяющий инвертировать поток управления.
                     
                     Для этого вы выносите все обязанности класса, кроме его основной, наружу, делая их его зависимостями. Благодаря абстракции (использованию протоколов) вы делаете зависимости легко взаимозаменяемыми.
                     """),
            
            Question(question: ["Помогает ли Dependency Inversion в соблюдении принципов SOLID?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 138183352,
                     helpText: """
                     Да. D в SOLID отвечает за DIP - dependency inversion principle (принцип инверсии зависимостей), или инверсия управления (IoC - Inversion of Control): «Зависимость на Абстракциях.
                     
                     Нет зависимости на что-то конкретное». Одним из способов соблюдения dependency inversion - как раз является dependency injection, построенный на протоколах.
                     
                     Внедрение зависимостей — это один из немногих шаблонов, который помогает применять принципы инверсии управления. Вы можете реализовать внедрение зависимостей несколькими способами, включая внедрение конструктора, внедрение сеттера.
                     """),
            
            Question(question: ["Помогает ли внедрение Dependency Inversion в тестировании кода?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 779969533,
                     helpText: "Да. Внедрение паттерна Dependency Inversion улучшает тестирование вашей архитектуры. После внедрения DI ваши классы зависят от протоколов (чаще всего), объекты которых легко подменить / имитировать фиктивными объектами классов для тестов."),
            
            Question(question: ["Внедрение Dependency Inversion ваш проект увеличивает связанность (coupling) объектов в проекте, или уменьшает?"],
                     image: "",
                     optionA: "Уменьшает",
                     optionB: "Увеличивает",
                     optionC: "",
                     optionD: "",
                     id: 173941371,
                     helpText: "Уменьшает. Внедрение Dependency Inversion в проект уменьшает связь между вашим классом и другими. Все зависимости внедряются в ваш класс извне, и каждый компонент / класс несет свою ответственность (Single-responsibility principle)."),
        ]
    }
}
