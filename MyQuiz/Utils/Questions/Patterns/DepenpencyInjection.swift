//
//  DepenpencyInjection.swift
//  Swifty-Quiz
//
//  Created by Евгений Никитин on 28.01.2022.
//  Copyright © 2022 Evel-Devel. All rights reserved.
//

import Foundation

final class DepenpencyInjection {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Есть ли в Swift нативные библиотеки, которые поддерживают паттерн Dependency Injection из коробки?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 656770121,
                     helpText: """
                     Нет. Одним из способов доставки зависимостей к классам является DI (Dependency Injection). В настоящее время это наиболее распространенный паттерн.
                     
                     Он настолько популярен, что в мире бэкенда все нормальные фреймворки поддерживают его из коробки. Нам, к сожалению, так не повезло.
                     """),
            
            Question(question: ["Помогает ли Dependency Injection в соблюдении принципов SOLID?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 138183352,
                     helpText: """
                     Да. D в SOLID отвечает за DIP - dependency inversion principle (принцип инверсии зависимостей), или инверсия управления (IoC - Inversion of Control): «Зависимость на Абстракциях. Нет зависимости на что-то конкретное».
                     
                     Одним из способов соблюдения dependency inversion - как раз является dependency injection, построенный на протоколах.
                     
                     Внедрение зависимостей — это один из немногих шаблонов, который помогает применять принципы инверсии управления. Вы можете реализовать внедрение зависимостей несколькими способами, включая внедрение конструктора, внедрение сеттера.
                     """),
            
            Question(question: ["Суть паттерна Dependency Injection заключается в том, что зависимости внедряются в класс извне. Так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 915216712,
                     helpText: """
                     Да. Одним из способов доставки зависимостей к классам является DI (Dependency Injection). В настоящее время это наиболее распространенный паттерн.
                     
                     Суть этого паттерна заключается в том, что зависимости внедряются в класс извне, при этом граф зависимостей строится внутри DI контейнера, который является «фабрикой» или набором «фабрик».
                     """),
            
            Question(question: ["При Dependency Injection зависимости внедряются в класс извне, где при этом строится граф зависимостей этого DI контейнера?"],
                     image: "",
                     optionA: "Внутри DI контейнера",
                     optionB: "Снаружи DI контейнера",
                     optionC: "Оба варианта неверны",
                     optionD: "",
                     id: 561542372,
                     helpText: """
                     Внутри DI контейнера. Одним из способов доставки зависимостей к классам является DI (Dependency Injection).
                     
                     В настоящее время это наиболее распространенный паттерн. Суть этого паттерна заключается в том, что зависимости внедряются в класс извне, при этом граф зависимостей строится внутри DI контейнера, который является «фабрикой» или набором «фабрик».
                     """),
            
            Question(question: ["Поощряется ли при использовании DI внедрение фабрик, которые берут на себя ответственность по сборке объектов?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 718822701,
                     helpText: """
                     Да. Dependency Injection поощряет вынос порождающей логики за предели классов. Всю ответственность по сборке на себя берут так называемые «фабрики».
                     
                     При желании количество этих «фабрик» можно увеличивать, чтобы не допускать разрастания классов. Хорошей практикой является создание «фабрики», ответственной за создание каких-либо родственных объектов.
                     
                     Например, эта «фабрика» может создать сервисы, контроллеры для конкретной user story.
                     """),
            
            Question(question: ["Выберите лишний вариант (разновидность DI, которой не существует)",
                                "Какая разновидность DI из этого списка не существует?",
                                "В этом списке присутствует разновидность DI, которой не существует. Какая?",],
                     image: "",
                     optionA: "Strong Injection",
                     optionB: "Property Injection",
                     optionC: "Method Injection",
                     optionD: "Constructor Injection",
                     id: 208178259,
                     helpText: """
                     Strong Injection. Существует три основных разновидности DI:
                     
                     - Property Injection (внедрение зависимостей через публичные свойства);
                     - Method Injection (внедрение зависимостей через публичные методы);
                     - Constructor Injection (он же Initializer Injection, внедрение зависимостей через конструктор);
                     
                     Еще есть менее используемый Interface Injection, но он не пользуется особой популярностью.
                     """),
            
            Question(question: ["Эта разновидность DI используется, когда класс не может существовать без своих зависимостей"],
                     image: "",
                     optionA: "Constructor Injection",
                     optionB: "Method Injection",
                     optionC: "",
                     optionD: "",
                     id: 234124975,
                     helpText: """
                     Constructor Injection. Constructor Injection / Initializer Injection — внедрение зависимостей через конструктор.
                     
                     Этот подход используется в случае, когда класс не может существовать без своих зависимостей, но даже если это не так, то его можно использовать для более явного определения контракта класса.
                     
                     Если все зависимости объявлены в качестве аргументов конструктора, определить их проще простого. Но не стоит увлекаться, если у класса десяток зависимостей, то лучше не передавать их в конструкторе (а еще лучше разобраться, зачем вашему классу столько зависимостей).
                     """),
            
            Question(question: ["Чаще всего эта разновидность DI используется когда у класса имеются необязательные зависимости"],
                     image: "",
                     optionA: "Property Injection",
                     optionB: "Method Injection",
                     optionC: "Strong Injection",
                     optionD: "",
                     id: 773583634,
                     helpText: "Property Injection. Property Injection — внедрение зависимостей через свойства. Этот способ используется, когда у класса имеются необязательные зависимости, без которых он может обойтись, или когда зависимости могут изменяться не только на этапе инициализации объекта."),
            
            Question(question: ["Какая разновидность DI используется, когда необходимо внедрить временную зависимость только на момент выполнения какого-либо действия"],
                     image: "",
                     optionA: "Method Injection",
                     optionB: "Constructor Injection",
                     optionC: "Initializer Injection",
                     optionD: "",
                     id: 418233554,
                     helpText: "Method Injection. Method Injection — внедрение зависимостей через метод. Этот способ очень похож на Property Injection, но с его помощью можно внедрить временную зависимость только на момент выполнения какого-либо действия или более тесно связать внедрение зависимости с логикой класса."),
            
            Question(question: ["Эта разновидность DI используется, когда все зависимости объявлены в качестве аргументов инициализатора"],
                     image: "",
                     optionA: "Constructor Injection",
                     optionB: "Property Injection",
                     optionC: "",
                     optionD: "",
                     id: 415735572,
                     helpText: """
                     Constructor Injection. Constructor Injection / Initializer Injection — внедрение зависимостей через конструктор.
                     
                     Этот подход используется в случае, когда класс не может существовать без своих зависимостей, но даже если это не так, то его можно использовать для более явного определения контракта класса.
                     
                     Если все зависимости объявлены в качестве аргументов конструктора, определить их проще простого. Но не стоит увлекаться, если у класса десяток зависимостей, то лучше не передавать их в конструкторе (а еще лучше разобраться, зачем вашему классу столько зависимостей).
                     """),
            
            Question(question: ["Эта разновидность DI используется когда зависимости могут изменяться не только на этапе инициализации объекта"],
                     image: "",
                     optionA: "Property Injection",
                     optionB: "Method Injection",
                     optionC: "Interface Injection",
                     optionD: "",
                     id: 773583634,
                     helpText: "Property Injection. Property Injection — внедрение зависимостей через свойства. Этот способ используется, когда у класса имеются необязательные зависимости, без которых он может обойтись, или когда зависимости могут изменяться не только на этапе инициализации объекта."),
            
            Question(question: ["Будет ли являться инициализация подобной константы let someService = SomeService() внутри класса - внедрением зависимости?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 771527552,
                     helpText: "Нет. Мы создаем внешнюю зависимость, но создаем ее локально. Мы ничего не внедряем в наш класс извне (а это главная отличительная черта внедрения зависимостей). Зависимость - это любой посторонний объект, который используется нашим классом, или на который наш класс рассчитывает."),
            
            Question(question: ["Если наш класс обращается к shared instance другого класса, с намерением стабильно получать определенный функционал - будет ли это считаться зависимостью?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 139027591,
                     helpText: """
                     Да. Зависимость - это любой посторонний объект, который используется нашим классом, или на который наш класс рассчитывает.
                     
                     Код, который использует обращение к статическому shared instance другого класса, можно охарактеризовать как «сильно связанный» (tightly coupled), но он не принимает никаких внешних зависимостей, а только создает локальную связь с shared объектом этого класса.
                     """),
            
            Question(question: ["Внедрение зависимостей через какой способ создает большое количество опциональных типов?"],
                     image: "",
                     optionA: "Property Injection",
                     optionB: "Constructor Injection",
                     optionC: "Ни через какой",
                     optionD: "",
                     id: 872613825,
                     helpText: """
                     Property Injection. При всей популярности property injection, он создает большое количество опциональных типов вокруг себя, и лучше использовать внедрение через инициализатор (конструктор).
                     
                     Так мы убираем большое количество опциональности, четко знаем, когда в нашем объекте устанавливается значение, и делаем наш код более очевидным и более читаемым.
                     
                     А если мы используем внедрение через конструктор, закрывая это протоколами - добавляем абстракцию и возможность для безболезненного масштабирования проекта.
                     """),
            
            Question(question: ["Является ли код с использованием Dependency Injection тестируемым?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 779969533,
                     helpText: "Да. Внедрение паттерна Dependency Injection улучшает тестирование вашей архитектуры. После внедрения DI ваши классы зависят от протоколов (чаще всего), объекты которых легко подменить / имитировать фиктивными объектами классов для тестов."),
            
            Question(question: ["Внедрение Dependency Injection ваш проект увеличивает связанность (coupling) объектов в проекте, или уменьшает?"],
                     image: "",
                     optionA: "Уменьшает",
                     optionB: "Увеличивает",
                     optionC: "",
                     optionD: "",
                     id: 173941371,
                     helpText: "Уменьшает. Внедрение Dependency Injection в проект уменьшает связь между вашим классом и другими. Все зависимости внедряются в ваш класс извне, и каждый компонент / класс несет свою ответственность (Single-responsibility principle)."),
        ]
    }
}
