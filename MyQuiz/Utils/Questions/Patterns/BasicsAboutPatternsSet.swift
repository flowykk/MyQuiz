
//  Created by Евгений Никитин on 13.07.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

final class BasicsAboutPatternsSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Что такое паттерн проектирования?"],
                     image: "",
                     optionA: "Часто встречающееся решение",
                     optionB: "Готовая библиотека",
                     optionC: "Фреймворк",
                     optionD: "Готовая функция",
                     id: 941076191,
                     helpText: """
                     Часто встречающееся решение. Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.
                     
                     В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу.
                     
                     Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет еще подстроить под нужды вашей программы.
                     """),
            
            Question(question: ["Можем ли мы просто брать и копировать паттерн в программу, для решения нашей проблемы?",
                                "Вы можете просто скопировать паттерн к себе в программу, решив свою проблему. Так ли это?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 294720054,
                     helpText: "Нет. Паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды вашей программы."),
            
            Question(question: ["Привязаны ли паттерны проектирования к определенному языку программирования?",
                                "Паттерны привязаны к определенному языку программирования?",
                                "Паттерны проектирования привязаны к конкретному языку программирования, так ли это?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 265999508,
                     helpText: """
                     Нет. Паттерны проектирования не привязаны к конкретному языку программирования. В некоторых областях находят более широкое применение одни паттерны и почти не используются остальные, в других направлениях картина может отличаться.
                     
                     Во многих современных языках программирования предусмотрены упрощенные синтаксические конструкции, позволяющие легко использовать некоторые паттерны. В Swift немало такого синтаксического сахара.
                     """),
            
            Question(question: ["Что лежит в основе порождающих паттернов?"],
                     image: "",
                     optionA: "Создание объектов",
                     optionB: "Управление поведением",
                     optionC: "Структурирование кода",
                     optionD: "",
                     id: 187630195,
                     helpText: "Создание объектов. В основе порождающих паттернов всегда лежит создание объектов."),
            
            Question(question: ["Кто впервые описал концепцию паттернов?",
                                "Концепцию паттернов впервые описал этот человек"],
                     image: "",
                     optionA: "Кристофер Александер",
                     optionB: "Аль-Хорезми",
                     optionC: "Джордж Буль",
                     optionD: "Джон Бэкус",
                     id: 983310880,
                     helpText: """
                     Кристофер Александер. Концепцию паттернов впервые описал Кристофер Александер в книге «Язык шаблонов. Города. Здания. Строительство».
                     
                     В книге описан «язык» для проектирования окружающей среды, единицы которого — шаблоны (или паттерны, что ближе к оригинальному термину patterns) — отвечают на архитектурные вопросы: какой высоты сделать окна, сколько этажей должно быть в здании, какую площадь в микрорайоне отвести под деревья и газоны.
                     """),
            
            Question(question: ["Что является основой поведенческих паттернов?"],
                     image: "",
                     optionA: "Управление поведением",
                     optionB: "Создание объектов",
                     optionC: "Структурирование кода",
                     optionD: "",
                     id: 262045579,
                     helpText: "Управление поведением. Поведенческие паттерны являются самой большой категорией, сюда входят все паттерны, которые так или иначе определяют поведение объектов и их взаимодействие друг с другом."),
            
            Question(question: ["Что лежит в основе структурных паттернов?"],
                     image: "",
                     optionA: "Структурирование кода",
                     optionB: "Управление поведением",
                     optionC: "Создание объектов",
                     optionD: "",
                     id: 783021294,
                     helpText: "Структурирование кода. Структурные паттерны позволяют лучше структурировать код, чтобы его было легче понимать."),
            
            Question(question: ["Используются ли паттерны в нативных библиотеках Apple?",
                                "Используют ли Apple паттерны проектирования внутри своих нативных библиотек?",
                                "Apple использует паттерны Delegate и Singleton в своих нативных библиотеках, так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 753240553,
                     helpText: """
                     Да. Как и делегат, синглтон часто используется в нативных библиотеках Apple. UIApplication.shared предоставляет доступ к экземпляру приложения. Этот объект всегда один в приложении.
                     
                     У приложения есть делегат, и он всегда один. Это как раз тот класс, который всегда по дефолту добавляется под именем AppDelegate при создании нового проекта в XCode. Обратиться к нему можно с помощью UIApplication.shared.delegate.
                     
                     FileManager.default предоставляет доступ к объекту-синглтону, с помощью которого можно управлять файловой системой. Можно, например, сохранить данные на диск, создать файлы и папки внутри sandbox-приложения.
                     """),
			
			Question(question: ["Порождающий шаблон проектирования, который предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Реализуется созданием абстрактного класса \"Фабрика\""],
					 image: "",
					 optionA: "Abstract factory",
					 optionB: "Factory method",
					 optionC: "Prototype",
					 optionD: "",
					 id: 676668969,
                     helpText: """
                     Abstract factory. Абстрактная фабрика (англ. Abstract factory) — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.
                     
                     Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки).
                     
                     Затем пишутся классы, реализующие этот интерфейс.
                     """),
			
			Question(question: ["Поведенческий шаблон проектирования, предназначенный для организации в системе уровней ответственности. Шаблон рекомендован для использования в условиях, когда все сообщения должны быть обработаны хотя бы одним объектом системы."],
					 image: "",
					 optionA: "Chain of responsibility",
					 optionB: "Abstract factory",
					 optionC: "Command",
					 optionD: "",
					 id: 877240500,
                     helpText: """
                     Chain of responsibility. Цепочка обязанностей (англ. Chain of responsibility) — поведенческий шаблон проектирования, предназначенный для организации в системе уровней ответственности.
                     
                     Шаблон рекомендован для использования в условиях:
                     - в разрабатываемой системе имеется группа объектов, которые могут обрабатывать сообщения определенного типа;
                     - все сообщения должны быть обработаны хотя бы одним объектом системы;
                     - сообщения в системе обрабатываются по схеме «обработай сам либо перешли другому», то есть одни сообщения обрабатываются на том уровне, где они получены, а другие пересылаются объектам иного уровня.
                     """),
			
			Question(question: ["Cтруктурный шаблон проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе."],
					 image: "",
					 optionA: "Adapter",
					 optionB: "Bridge",
					 optionC: "Factory method",
					 optionD: "",
					 id: 386143283,
                     helpText: """
                     Adapter. Адаптер (англ. Adapter) — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.
                     
                     Другими словами — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.
                     """),
			
			Question(question: ["Порождающий шаблон проектирования предоставляет способ создания составного объекта."],
					 image: "",
					 optionA: "Builder",
					 optionB: "Composite",
					 optionC: "Iterator",
					 optionD: "",
					 id: 788441694,
                     helpText: """
                     Builder. Строитель (англ. Builder) — порождающий шаблон проектирования предоставляет способ создания составного объекта.
                     
                     Отделяет конструирование сложного объекта от его представления так, что в результате одного и того же процесса конструирования могут получаться разные представления.
                     
                     Плюсы: позволяет изменять внутреннее представление продукта; изолирует код, реализующий конструирование и представление; дает более тонкий контроль над процессом конструирования.
                     """),
			
			Question(question: ["Структурный шаблон проектирования, используемый для того, чтобы «разделять абстракцию и реализацию так, чтобы они могли изменяться независимо»"],
					 image: "",
					 optionA: "Bridge",
					 optionB: "Prototype",
					 optionC: "Observer",
					 optionD: "",
					 id: 925952864,
                     helpText: """
                     Bridge. Шаблон мост (англ. Bridge) — структурный шаблон проектирования, используемый для того, чтобы «разделять абстракцию и реализацию так, чтобы они могли изменяться независимо».
                     
                     Мост использует инкапсуляцию, агрегирование и может использовать наследование для того, чтобы разделить ответственность между классами.
                     
                     При реализации через шаблон мост, изменение структуры интерфейса не мешает изменению структуры реализации.
                     """),
			
			Question(question: ["Поведенческий шаблон проектирования, который заключает в себе действие и его параметры."],
					 image: "",
					 optionA: "Command",
					 optionB: "Visitor",
					 optionC: "Strategy",
					 optionD: "",
					 id: 724363619,
                     helpText: """
                     Command. Команда (англ. Command) — поведенческий шаблон проектирования, используемый при объектно-ориентированном программировании, представляющий действие.
                     
                     Объект команды заключает в себе само действие и его параметры. Шаблон используется для создания структуры, в которой класс-отправитель и класс-получатель не зависят друг от друга напрямую, и для организации обратного вызова к классу, который включает в себя класс-отправитель.
                     """),
			
			Question(question: ["Порождающий шаблон проектирования, предоставляющий подклассам (дочерним классам) интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать"],
					 image: "",
					 optionA: "Factory Method",
					 optionB: "Abstract factory",
					 optionC: "Flyweight",
					 optionD: "Template method",
					 id: 207701252,
                     helpText: """
                     Factory Method. Фабричный метод (англ. Factory Method) — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса.
                     
                     В момент создания наследники могут определить, какой класс создавать. Данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.
                     
                     Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, на основании какого класса создавать объект.
                     """),
			
			Question(question: ["Структурный шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому"],
					 image: "",
					 optionA: "Composite",
					 optionB: "Decorator",
					 optionC: "Iterator",
					 optionD: "",
					 id: 401396647,
                     helpText: """
                     Composite. Компоновщик (англ. Composite pattern) — структурный шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому.
                     
                     Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково. Паттерн определяет иерархию классов, которые одновременно могут состоять из примитивных и сложных объектов, упрощает архитектуру клиента, делает процесс добавления новых видов объекта более простым.
                     """),
			
			Question(question: ["Cтруктурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту"],
					 image: "",
					 optionA: "Decorator",
					 optionB: "Composite",
					 optionC: "Mediator",
					 optionD: "",
					 id: 934394978,
                     helpText: """
                     Decorator. Декоратор (англ. Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту.
                     
                     Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.
                     
                     Задача: объект, который предполагается использовать, выполняет основные функции. Однако может потребоваться добавить к нему некоторую дополнительную функциональность, которая будет выполняться до, после или даже вместо основной функциональности объекта.
                     """),
			
			Question(question: ["Поведенческий паттерн проектирования, который позволяет получить последовательный доступ к элементам объекта без использования описаний каждого из этих объектов"],
					 image: "",
					 optionA: "Iterator",
					 optionB: "Memento",
					 optionC: "Mediator",
					 optionD: "",
					 id: 483949215,
                     helpText: """
                     Iterator. Поведенческий шаблон проектирования. Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого из агрегированных объектов.
                     
                     Такие элементы как дерево, связанный список, хеш-таблица и массив могут быть пролистаны (и модифицированы) с помощью объекта Итератор. Перебор элементов выполняется объектом итератора, а не самой коллекцией.
                     
                     Это упрощает интерфейс и реализацию коллекции, а также способствует более логичному разделению обязанностей. Особенностью полноценно реализованного итератора является то, что код, использующий итератор, может ничего не знать о типе итерируемого агрегата.
                     """),
			
			Question(question: ["Поведенческий шаблон проектирования, обеспечивающий взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга"],
					 image: "",
					 optionA: "Mediator",
					 optionB: "Decorator",
					 optionC: "Command",
					 optionD: "",
					 id: 541178825,
                     helpText: """
                     Mediator. Посредник (англ. Mediator) — поведенческий шаблон проектирования, обеспечивающий взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.
                     
                     Проблема: Обеспечить взаимодействие множества объектов, сформировав при этом слабую связанность и избавив объекты от необходимости явно ссылаться друг на друга. Решение: Создать объект, инкапсулирующий способ взаимодействия множества объектов.
                     """),
			
			Question(question: ["Порождающий шаблон проектирования, гарантирующий, что в однопоточном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру"],
					 image: "",
					 optionA: "Singleton",
					 optionB: "Memento",
					 optionC: "Observer",
					 optionD: "",
					 id: 399063832,
                     helpText: """
                     Singleton. Одиночка (англ. Singleton) — порождающий шаблон проектирования, гарантирующий, что в однопоточном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.
                     
                     Цель: У класса есть только один экземпляр, и он предоставляет к нему глобальную точку доступа. При попытке создания данного объекта он создаётся только в том случае, если ещё не существует, в противном случае возвращается ссылка на уже существующий экземпляр и нового выделения памяти не происходит.
                     
                     Существенно то, что можно пользоваться именно экземпляром класса, так как при этом во многих случаях становится доступной более широкая функциональность.
                     """),
			
			Question(question: ["Поведенческий шаблон проектирования, позволяющий, не нарушая инкапсуляцию, зафиксировать и сохранить внутреннее состояние объекта так, чтобы позднее восстановить его в это состояние"],
					 image: "",
					 optionA: "Memento",
					 optionB: "State",
					 optionC: "Strategy",
					 optionD: "",
					 id: 168558599,
                     helpText: """
                     Memento. Хранитель (англ. Memento) — поведенческий шаблон проектирования, позволяющий, не нарушая инкапсуляцию, зафиксировать и сохранить внутреннее состояние объекта так, чтобы позднее восстановить его в это состояние.
                     
                     Шаблон Хранитель используется, когда: необходимо сохранить снимок состояния объекта (или его части) для последующего восстановления, прямой интерфейс получения состояния объекта раскрывает детали реализации и нарушает инкапсуляцию объекта.
                     """),
			
			Question(question: ["Поведенческий шаблон проектирования, который реализует у класса механизм, позволяющий объекту этого класса получать оповещения об изменении состояния других объектов и тем самым наблюдать за ними"],
					 image: "",
					 optionA: "Observer",
					 optionB: "Facade",
					 optionC: "Flyweight",
					 optionD: "Delegate",
					 id: 740104237,
                     helpText: """
                     Observer. Наблюдатель (англ. Observer) — поведенческий шаблон проектирования. Также известен как «подчинённые» (Dependents).
                     
                     Реализует у класса механизм, который позволяет объекту этого класса получать оповещения об изменении состояния других объектов и тем самым наблюдать за ними.
                     
                     Классы, на события которых другие классы подписываются, называются субъектами (Subjects), а подписывающиеся классы называются наблюдателями (Observers).
                     """),
			
			Question(question: ["Cтруктурный шаблон проектирования, позволяющий скрыть сложность системы путём сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы"],
					 image: "",
					 optionA: "Facade",
					 optionB: "Observer",
					 optionC: "Proxy",
					 optionD: "Decorator",
					 id: 730567715,
                     helpText: """
                     Facade. Шаблон фасад (англ. Facade) — структурный шаблон проектирования, позволяющий скрыть сложность системы путём сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.
                     
                     Проблема: Как обеспечить унифицированный интерфейс с набором разрозненных реализаций или интерфейсов, например, с подсистемой, если нежелательно сильное связывание с этой подсистемой или реализация подсистемы может измениться?
                     
                     Решение: Определить одну точку взаимодействия с подсистемой — фасадный объект, обеспечивающий общий интерфейс с подсистемой, и возложить на него обязанность по взаимодействию с её компонентами. Фасад — это внешний объект, обеспечивающий единственную точку входа для служб подсистемы.
                     """),
			
			Question(question: ["Cтруктурный шаблон проектирования, при котором объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым"],
					 image: "",
					 optionA: "Flyweight",
					 optionB: "Singleton",
					 optionC: "Composite",
					 optionD: "",
					 id: 195105640,
                     helpText: """
                     Flyweight. Приспособленец (англ. flyweight, «легковесный») — структурный шаблон проектирования, при котором объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым.
                     
                     Flyweight используется для уменьшения затрат при работе с большим количеством мелких объектов. При проектировании приспособленца необходимо разделить его свойства на внешние и внутренние.
                     
                     Внутренние свойства всегда неизменны, тогда как внешние могут отличаться в зависимости от места и контекста применения и должны быть вынесены за пределы приспособленца.
                     """),
			
			Question(question: ["Cтруктурный шаблон проектирования, предоставляющий объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера)"],
					 image: "",
					 optionA: "Proxy",
					 optionB: "Decorator",
					 optionC: "Facade",
					 optionD: "Bridge",
					 id: 897666085,
                     helpText: """
                     Proxy. Заместитель (англ. Proxy) — структурный шаблон проектирования, предоставляющий объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера).
                     
                     Шаблон Proxy может применяться в случаях работы с сетевым соединением, с огромным объектом в памяти (или на диске) или с любым другим ресурсом, который сложно или тяжело копировать. Хорошо известный пример применения — объект, подсчитывающий число ссылок.
                     """),
			
			Question(question: ["Поведенческий шаблон проектирования, который используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния"],
					 image: "",
					 optionA: "State",
					 optionB: "Strategy",
					 optionC: "Command",
					 optionD: "Iterator",
					 id: 289102789,
                     helpText: """
                     State. Состояние (англ. State) — поведенческий шаблон проектирования. Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.
                     
                     Применение данного паттерна может быть затруднено, если состояния должны обмениваться данными, или одно состояние настраивает свойства другого.
                     
                     В этом случае понадобится глобальный объект, что не очень хорошее архитектурное решение.
                     """),
			
			Question(question: ["Поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Алгоритмы можно менять во время исполнения программы"],
					 image: "",
					 optionA: "Strategy",
					 optionB: "State",
					 optionC: "Mediator",
					 optionD: "Builder",
					 id: 281571131,
                     helpText: """
                     Strategy. Стратегия (англ. Strategy) — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
                     
                     Это позволяет выбирать алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.
                     """),
			
			Question(question: ["Поведенческий шаблон проектирования, определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом"],
					 image: "",
					 optionA: "Template method",
					 optionB: "Factory method",
					 optionC: "Abstract Factory",
					 optionD: "Proxy",
					 id: 554019753,
					 helpText: "Template method. Шаблонный метод (англ. Template method) — поведенческий шаблон проектирования, определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом."),
			
			Question(question: ["Поведенческий шаблон проектирования, описывающий операцию, которая выполняется над объектами других классов"],
					 image: "",
					 optionA: "Visitor",
					 optionB: "Strategy",
					 optionC: "Facade",
					 optionD: "Prototype",
					 id: 515890421,
                     helpText: """
                     Visitor. Посетитель (англ. visitor) — поведенческий шаблон проектирования, описывающий операцию, которая выполняется над объектами других классов. При изменении visitor нет необходимости изменять обслуживаемые классы.
                     
                     Шаблон демонстрирует классический приём восстановления информации о потерянных типах, не прибегая к понижающему приведению типов при помощи двойной диспетчеризации.
                     
                     Решаемая проблема: Необходимо сделать какие-то несвязные операции над рядом объектов, но нужно избежать загрязнения их кода. И нет возможности или желания запрашивать тип каждого узла и осуществлять приведение указателя к правильному типу, прежде чем выполнить нужную операцию.
                     """)
        ]
    }
}
