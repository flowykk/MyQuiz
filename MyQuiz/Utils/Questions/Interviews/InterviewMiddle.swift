//
//  Interview.swift
//  Swifty-Quiz
//
//  Created by Евгений Никитин on 20.01.2023.
//  Copyright © 2023 Evel-Devel. All rights reserved.
//

import Foundation

final class InterviewMiddle {
    static func getQuestions() -> [Question] {
        return [
            Question(question: [
                "Область памяти, для которой свойственно статическое выделение, которое происходит только во время компиляции"
            ],
                     image: "",
                     optionA: "Стек",
                     optionB: "Куча",
                     optionC: "",
                     optionD: "",
                     id: 486217799,
                     links: [
                        "https://habr.com/ru/post/592385/"
                     ],
                     helpText: """
                     Стек. Область памяти, для которой свойственно статическое выделение памяти, которое происходит только во время компиляции.

                     Переменные, выделенные в стеке, хранятся непосредственно в памяти, и доступ к этой памяти очень быстрый, и ее выделение определяется при компиляции программы. Он организован по принципу «последним пришёл — первым вышел» (LIFO).

                     Существует ограничение в том, что данные, которые предполагается хранить в стеке, обязаны быть конечными и статичными — их размер должен быть известен ещё на этапе компиляции. Каждый поток многопоточного приложения имеет доступ к своему собственному стеку.
                     """
                    ),

            Question(question: [
                "Область памяти, для которой свойственно динамическое выделение, которое происходит во время выполнения"
            ],
                     image: "",
                     optionA: "Куча",
                     optionB: "Стек",
                     optionC: "",
                     optionD: "",
                     id: 607469139,
                     links: [
                        "https://habr.com/ru/post/592385/"
                     ],
                     helpText: """
                     Куча. Используется для динамического выделения памяти, однако, в отличие от стека, данные в куче первым делом требуется найти с помощью «оглавления». Можно представить, что куча это такая большая многоуровневая библиотека, в которой, следуя определённым инструкциям, можно найти необходимую книгу.

                     Операции на куче производятся несколько медленнее, чем на стеке, так как требуют дополнительного этапа для поиска данных. В куче хранятся данные динамических размеров, например, список, в который можно добавлять произвольное количество элементов. Куча общая для всех потоков приложения.

                     Вследствие динамической природы, куча нетривиальна в управлении и с ней возникает большинство всех проблем и ошибок, связанных с памятью. Способы решения этих проблем предоставляются языками программирования.
                     """
                    ),
            
            Question(question: [
                "При использовании какого типа ссылок создается Side Table?"
            ],
                     image: "",
                     optionA: "weak",
                     optionB: "strong",
                     optionC: "",
                     optionD: "",
                     id: 997363445,
                     links: [
                        "https://habr.com/ru/post/592385/"
                     ],
                     helpText: """
                     weak. Обычно объекты не имеют слабых ссылок, поэтому резервировать место для подсчета слабых ссылок в каждом объекте нецелесообразно. Эта информация хранится извне в дополнительных таблицах, поэтому ее можно выделить только тогда, когда это действительно необходимо.

                     Как только мы начинаем ссылаться на объект слабо (weak reference), то создается боковая таблица, и теперь объект вместо сильного счетчика ссылок хранит ссылку на боковую таблицу. Сама боковая таблица также имеет ссылку на объект.

                     Side Table — это просто счетчик ссылок + указатель на объект. Они объявлены в Swift Runtime, кодом C++.
                     """
                    ),
            
            Question(question: [
                "Где хранятся Value Type в Swift?"
            ],
                     image: "",
                     optionA: "В стеке",
                     optionB: "В куче",
                     optionC: "",
                     optionD: "",
                     id: 582577324,
                     links: [
                        "https://habr.com/ru/post/592385/"
                     ],
                     helpText: """
                     В стеке. Value Type - Хранятся в стеке. Каждая переменная имеет свою собственную копию данных, и операции с одной не влияют на другую.
                     """
                    ),
            
            Question(question: [
                "Где преимущественно хранятся Reference Type в Swift?"
            ],
                     image: "",
                     optionA: "В куче",
                     optionB: "В стеке",
                     optionC: "",
                     optionD: "",
                     id: 444268627,
                     links: [
                        "https://habr.com/ru/post/592385/"
                     ],
                     helpText: """
                     В куче. ReferenceType - Хранятся в куче. Переменные ссылочного типа могут указывать на одни и те же данные, следовательно, операции с одной переменной могут повлиять на данные, указанные другой переменной.

                     Компилятор Swift может размещать ссылочные типы в стеке, когда их размер фиксирован или время жизни может быть предсказано. Эта оптимизация происходит на этапе генерации SIL.

                     Swift Intermediate Language (SIL) - это промежуточный язык высокого уровня, ориентированный на Swift, подходящий для дальнейшего анализа и оптимизации кода Swift.
                     """
                    ),
            
            Question(question: [
                "Сколько может быть областей памяти, для которой свойственно динамическое выделение (куча)?"
            ],
                     image: "",
                     optionA: "Одна",
                     optionB: "Две",
                     optionC: "Неограниченное кол-во",
                     optionD: "",
                     id: 321702655,
                     links: [
                        "https://habr.com/ru/post/592385/"
                     ],
                     helpText: """
                     Одна. Куча одна, общая для всех потоков.
                     Стек для каждого потока свой. Сколько потоков, столько и стеков.
                     """
                    ),

            Question(question: [
                "Для каждого потока выделяется свой стек в памяти, так ли это?"
            ],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 198930007,
                     links: [
                        "https://habr.com/ru/post/592385/"
                     ],
                     helpText: """
                     Да. Каждый поток многопоточного приложения имеет доступ к своему собственному стеку.
                     """
                    ),

            Question(question: [
                "Фреймворк, написанный на языке С, позволяющий комфортно и достаточно просто управлять потоками, задачами для выполнения и ресурсами в Swift"
            ],
                     image: "",
                     optionA: "GCD",
                     optionB: "Operation",
                     optionC: "Thread",
                     optionD: "UIKit",
                     id: 686933812,
                     links: [
                        "https://habr.com/ru/post/578752/"
                     ],
                     helpText: """
                     GCD. Dispatch, больше известный как GCD – фреймворк, содержащий в себе языковые конструкции, позволяющие нам комфортно и достаточно просто управлять потоками, задачами для выполнения и ресурсами, которые нам необходимо захватить.

                     GCD работает на системном уровне, таким образом он может удовлетворить потребности всех запущенных приложений на девайсе, при этом управляя ресурсами эффективно.

                     GCD реализован на языке C, поэтому фактически является низкоуровневым фреймворком. Однако начиная со Swift 3.0 обзавелся читаемым Swift API. GCD поддерживается как в iOS, так и в macOS, watchOS и tvOS
                     """
                    ),

            Question(question: [
                "Какому паттерну следуют очереди (queues) в Swift?"
            ],
                     image: "",
                     optionA: "FIFO",
                     optionB: "LIFO",
                     optionC: "",
                     optionD: "",
                     id: 778454967,
                     links: [
                        "https://habr.com/ru/post/320152/",
                        "https://habr.com/ru/post/578752/"
                     ],
                     helpText: """
                     FIFO. Очереди (queues) следуют FIFO паттерну (First In, First Out), это означает, что тот, кто первым был поставлен в очередь, будет первым направлен на выполнение.

                     У вас может быть множество очередей (queues) и система “выдергивает” замыкания по одному из каждой очереди и запускает их на выполнение в их собственных потоках.

                     Таким образом, вы получаете многопоточность.
                     """
                    ),
            
            Question(question: [
                "Cитуация в многопоточной системе, при которой несколько потоков находятся в состоянии бесконечного ожидания ресурсов, занятых этими потоками"
            ],
                     image: "",
                     optionA: "Deadlock",
                     optionB: "Race condition",
                     optionC: "Data race",
                     optionD: "",
                     id: 171028339,
                     links: [
                        "https://habr.com/ru/post/578752/"
                     ],
                     helpText: """
                     Deadlock. Взаимная блокировка (deadlock) — ситуация в многопоточной системе, при которой несколько потоков находятся в состоянии бесконечного ожидания ресурсов, занятых самими этими потоками

                     Самый простой пример - вызвать DispatchQueue.main.sync { someCode() } на главном потоке.

                     В этом случае главный поток будет ожидать выполнения функции someCode, в тоже время выполнение функции someCode не начнется, пока главный поток не освободиться.
                     """
                    ),

            Question(question: [
                "Ситуация в многопоточной системе, при которой ожидаемый порядок выполнения операций становится непредсказуемым"
            ],
                     image: "",
                     optionA: "Race condition",
                     optionB: "Deadlock",
                     optionC: "Data race",
                     optionD: "",
                     id: 783082496,
                     links: [
                        "https://habr.com/ru/post/578752/"
                     ],
                     helpText: """
                     Race condition. Race condition это ситуация в многопоточных системах, при которой ожидаемый порядок выполнения операций становится непредсказуемым, в результате чего страдает закладываемая логика.
                     """
                    ),

            Question(question: [
                "Ситуация в многопоточном приложении, когда два или более потока пытаются получить доступ к одной и той же переменной без синхронизации"
            ],
                     image: "",
                     optionA: "Data race",
                     optionB: "Race condition",
                     optionC: "Deadlock",
                     optionD: "",
                     id: 796024549,
                     links: [
                        "https://habr.com/ru/company/otus/blog/353414/",
                        "https://www.avanderlee.com/swift/race-condition-vs-data-race/",
                        "https://developer.apple.com/documentation/xcode/data-races"
                     ],
                     helpText: """
                     Data race. Гонка данных возникает, когда два или более потока пытаются получить доступ к одной и той же переменной без синхронизации.

                     Отсутствие синхронизации может привести к внесению изменений, которые не будут видны другим потокам, из-за этого возможно чтение устаревших данных, что, в свою очередь, приводит к бесконечным циклам, поврежденным структурам данных или неточным вычислениям.
                     """
                    ),
            
            Question(question: [
                "Что мы получим в консоль?"
            ],
                     image: "Interview01",
                     optionA: "1 3 2",
                     optionB: "1 2 3",
                     optionC: "2 1 3",
                     optionD: "",
                     id: 108073508,
                     helpText: """
                     1 3 2. Если функция gsd() вызывается на главном потоке, то вывод всегда будет равен 1 3 2. Потому что главная очередь последовательная, и в момент добавления замыкания print(2), на главной очереди идет выполнение функции gsd().

                     Последовательные очереди не могут начать выполнение задачи, пока не завершат текущую. print(2) вызовется, как только главная очередь освободится, то есть после завершения функции gsd().

                     Если функцию gdcTest запустить на фоновом потоке, то в этом случае вывод тоже будет равен 1 3 2, в большинстве случаев.

                     Но не всегда, поскольку тут у нас появляется race condition, главный и фоновый потоки будут выполнять print(2) и print(3) паралельно. Что приведет к непредсказуемости порядка вывода. Убедится в наличии race condition можно добавив sleep(1) перед print(3)
                     """
                    ),
            
            Question(question: [
                "Можем ли мы отменять задачи у DispatchWorkItem в GCD с помощью метода cancel?"
            ],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 412214603,
                     links: [
                        "https://habr.com/ru/post/578752/#Dispatch%20group"
                     ],
                     helpText: """
                     Да. DispatchWorkItem дает нам возможность отменять задачу с помощью метода cancel. Важно понимать, что задачу можно отменить только в том случае, если она на момент отмены ожидает в очереди. Если поток уже начал выполнять задачу, она не будет отменена.

                     Операции Operations можно отменять с помощью их собственного метода cancel() или все операции сразу на определенной OperationQueue. Также можно отменять замыкания в BlockOperation.
                     """
                    ),

            Question(question: [
                "Можем ли мы отменить задачу DispatchWorkItem в GCD, если поток уже начал ее выполнение?"
            ],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 868586244,
                     links: [
                        "https://habr.com/ru/post/578752/#Dispatch%20group"
                     ],
                     helpText: """
                     Нет. DispatchWorkItem дает нам возможность отменять задачу с помощью метода cancel. Важно понимать, что задачу можно отменить только в том случае, если она на момент отмены ожидает в очереди. Если поток уже начал выполнять задачу, она не будет отменена.

                     Операции Operations можно отменять с помощью их собственного метода cancel() или все операции сразу на определенной OperationQueue. Также можно отменять замыкания в BlockOperation.
                     """
                    ),

            Question(question: [
                "Мы можем отменять задачи в Operations как по отдельности, так и все операции на определенной OperationQueue сразу. Так ли это?"
            ],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "Только по отдельности",
                     optionD: "",
                     id: 977593992,
                     links: [
                        "https://habr.com/ru/post/578752/#Dispatch%20group"
                     ],
                     helpText: """
                     Да. Операции Operations можно отменять с помощью их собственного метода cancel() или все операции сразу на определенной OperationQueue. Также можно отменять замыкания в BlockOperation.
                     """
                    ),
            
            Question(question: [
                "Может ли RunLoop вашего приложения управлять своим потоком? Например: будить для выполнения некоторой работы?",
                "Может ли RunLoop вашего приложения управлять своим потоком? Например: переводить в спящий режим после выполнения некоторой работы?"
            ],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 996665439,
                     links: [
                        "https://habr.com/ru/articles/572316/",
                        "https://habr.com/ru/company/otus/blog/590319/"
                     ],
                     helpText: """
                     Да. RunLoop умеет управлять своим потоком: будить для выполнения некоторой работы и переводить в спящий режим после ее выполнения.
                     
                     RunLoop автоматически переключается между активным состоянием (когда есть задачи для выполнения) и состоянием ожидания (когда нет задач).

                     RunLoop имеет множество возможностей для управления потоком выполнения, таких как добавление и удаление источников событий, установка таймеров, изменение режимов выполнения и другие.
                     """
                    ),
            
            Question(question: [
                "Является ли RunLoop потокобезопасным?"
            ],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 975206389,
                     links: [
                        "https://habr.com/ru/articles/572316/",
                        "https://habr.com/ru/company/otus/blog/590319/"
                     ],
                     helpText: """
                     Нет. Объект типа RunLoop не потокобезопасен, не следует обращаться к RunLoop одного потока из другого потока.
                     """
                    ),
            
            Question(question: [
                "Этот механизм DispatchQueue позволяет добавить синхронизацию задач в .concurrent очередь?"
            ],
                     image: "",
                     optionA: "Barrier",
                     optionB: "Semaphore",
                     optionC: "Group",
                     optionD: "",
                     id: 318426331,
                     links: [
                        "https://habr.com/ru/post/578752"
                     ],
                     helpText: """
                     Dispatch barrier. Это механизм синхронизации задач в очереди. Для того, чтобы добавить барьер, необходимо передать соответствующий флаг в метода async.

                     Когда мы добавляем барьер в параллельную очередь, она откладывает выполнение задачи, помеченной барьером (и все остальные, которые поступят в очередь во время выполнения такой задачи), до тех пор, пока все предыдущие задачи не будут выполнены.

                     После того, как все предудщие задачи будут выполнены, очередь выполнит задачу, помеченную барьером самостоятельно. Как только задача с барьером будет выполнена, очередь вернется к своему нормальному режиму работы.
                     """
                    ),
            
            Question(question: [
                "Имеет ли смысл использовать [weak self] во внутреннем замыкании?"
            ],
                     image: "ARC06",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 719762870,
                     links: [
                        "https://swiftbook.ru/content/languageguide/automatic-reference-counting/",
                        "https://stackoverflow.com/questions/41991467/where-does-the-weak-self-go"
                     ],
                     helpText: """
                     Нет. Писать weak self во внутреннем замыкании не имеет смысла, поскольку внешнее замыкание уже захватывает self по слабой ссылке.
                     """
                    ),
            
            Question(question: [
                "Должны ли мы использовать [weak self] в данном случае?"
            ],
                     image: "ARC01",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "Зависит от ситуации",
                     optionD: "",
                     id: 923997241,
                     links: [
                        "https://swiftbook.ru/content/languageguide/automatic-reference-counting/",
                        "https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting",
                        "https://www.youtube.com/watch?v=0sOrVoLOf7Q"
                     ],
                     helpText: """
                     Нет. В данном случае использование [weak self] внутри замыкания map не обязательно, так как map является non-escaping closure.
                     
                     То есть замыкание используется только временно, для преобразования значений массива [1, 2, 3] с использованием метода format, и затем оно освобождается.
                     
                     Оно не сохраняется для последующего использования, поэтому здесь нет необходимости использовать [weak self].
                     """
                    ),
            
            Question(question: [
                "Обязаны ли мы указывать self при использовании format(value)?"
            ],
                     image: "ARC02",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "Зависит от ситуации",
                     optionD: "",
                     id: 831980655,
                     links: [
                        "https://swiftbook.ru/content/languageguide/automatic-reference-counting/",
                        "https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting",
                        "https://www.youtube.com/watch?v=0sOrVoLOf7Q"
                     ],
                     helpText: """
                     Нет. map является non-escaping closure, поэтому если убрать self - компилятор не будет возражать.
                     
                     По этой же причине здесь нет необходимости использовать [weak self].
                     """
                    ),
            
            Question(question: [
                "Обязательно ли писать [weak self] в данном случае?"
            ],
                     image: "ARC03",
                     optionA: "Зависит от ситуации",
                     optionB: "Нет",
                     optionC: "Да",
                     optionD: "",
                     id: 158133098,
                     links: [
                        "https://swiftbook.ru/content/languageguide/automatic-reference-counting/",
                        "https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting",
                        "https://www.youtube.com/watch?v=0sOrVoLOf7Q"
                     ],
                     helpText: """
                     Зависит от ситуации. Большинство будет настаивать на том, что использование слабой ссылки здесь обязательно (asyncAfter является @escaping замыканием), что так будет правильнее и нагляднее, но все зависит от поведения, которое вы преследуете.
                     
                     Если вы хотите внутри блока отправить, например, некую собираемую статистику, вы можете не использовать слабую ссылку, и уходя с экрана - ровно через две секунды (или смотря сколько будет задержка), замыкание выполнится, и экран будет деинициализирован.
                     
                     Утечки памяти не произойдет, но ваша логика выполнится, потому что объект не будет к этому времени удален из памяти.
                     """
                    ),
            
            Question(question: [
                "Будет ли объект деинициализирован в таком случае?"
            ],
                     image: "ARC04",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     id: 907876486,
                     links: [
                        "https://swiftbook.ru/content/languageguide/automatic-reference-counting/",
                        "https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting",
                        "https://www.youtube.com/watch?v=0sOrVoLOf7Q"
                     ],
                     helpText: """
                     Да. Объект деинициализируется после задержки, когда замыкание выполнится (если мы больше никаким другим образом не держим этот объект, например - ушли с контроллера и он больше не используется).
                     """
                    ),
            
            Question(question: [
                "Какой вывод мы получим в консоль?"
            ],
                     image: "Multithreading01",
                     optionA: "1 -> 3 -> 2",
                     optionB: "1 -> 2 -> 3",
                     optionC: "Получим ошибку",
                     optionD: "",
                     id: 266328081,
                     links: [
                        "https://habr.com/ru/articles/320152/",
                        "https://developer.apple.com/documentation/DISPATCH"
                     ],
                     helpText: """
                     1 -> 3 -> 2. Здесь мы видим выполнение асинхронной задачи на глобальной очереди. Вот как это происходит:

                     Сначала будет выведено "1", так как это первая инструкция в коде.

                     Затем вызывается DispatchQueue.global().async. Код внутри замыкания представляет собой асинхронную задачу, которая будет выполнена в фоновом потоке, то есть выполнение кода продолжится дальше без ожидания окончания ее выполнения, поэтому дальше будет выведено "3".
                     
                     "2" выводится в конце, после "3".
                     """
                    ),
            
            Question(question: [
                "Будет ли очередность вывода цифр в консоль постоянной?"
            ],
                     image: "Multithreading02",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 785621932,
                     links: [
                        "https://habr.com/ru/articles/320152/",
                        "https://developer.apple.com/documentation/DISPATCH"
                     ],
                     helpText: """
                     Нет. Асинхронная задача выполняется в фоновом потоке параллельно с основным потоком выполнения кода, и порядок выполнения может быть разным каждый раз при запуске программы.
                     
                     Цифры 3 чаще всего будут "перемешаны" с цифрами "2", и предсказать порядок их вывода невозможно, он всегда будет случайным.
                     """
                    ),
            
            Question(question: [
                "Каким будет порядок вывода результата в консоль?"
            ],
                     image: "Multithreading03",
                     optionA: "Всегда разным",
                     optionB: "Постоянным, сначала 1",
                     optionC: "Постоянным, сначала 2",
                     optionD: "",
                     id: 327886983,
                     links: [
                        "https://habr.com/ru/articles/320152/",
                        "https://developer.apple.com/documentation/DISPATCH"
                     ],
                     helpText: """
                     Всегда разным. Две асинхронные задачи выполняются в фоновом потоке параллельно друг другу, и порядок выполнения может быть разным каждый раз при запуске программы.
                     """
                    ),
            
            Question(question: [
                "Какой порядок вывода мы получим в консоль?"
            ],
                     image: "Multithreading04",
                     optionA: "1 -> 3 -> 2",
                     optionB: "1 -> 2 -> 3",
                     optionC: "Получим ошибку",
                     optionD: "",
                     id: 896481746,
                     links: [
                        "https://habr.com/ru/articles/320152/",
                        "https://developer.apple.com/documentation/DISPATCH"
                     ],
                     helpText: """
                     1 -> 3 -> 2. Когда мы используем DispatchQueue.main.async, мы добавляем асинхронную задачу в главную очередь.
                     
                     Это означает, что данная задача будет выполнена в главном потоке, но не сразу же после добавления, вместо этого она будет выполнена, когда главный поток освободится от выполнения других задач.
                     
                     Это может быть после того, как текущий print("3") завершит свою работу.
                     
                     Второй print выполняется сразу после добавления задачи в очередь, и так как он не связан с асинхронностью, он будет завершен быстрее.
                     """
                    ),
            
            Question(question: [
                "Выберите корректную последовательность чисел в консоли"
            ],
                     image: "Multithreading05",
                     optionA: "2 -> 1",
                     optionB: "1 -> 2",
                     optionC: "",
                     optionD: "",
                     id: 758384307,
                     links: [
                        "https://habr.com/ru/articles/320152/",
                        "https://developer.apple.com/documentation/DISPATCH"
                     ],
                     helpText: """
                     2 -> 1. Когда мы используем DispatchQueue.main.async, мы добавляем асинхронную задачу в главную очередь.
                     
                     Это означает, что данная задача будет выполнена в главном потоке, но не сразу же после добавления, вместо этого она будет выполнена, когда главный поток освободится от выполнения других задач.
                     
                     Это может быть после того, как текущий print("2") завершит свою работу.
                     
                     Второй print выполняется сразу после добавления задачи в очередь, и так как он не связан с асинхронностью, он будет завершен быстрее.
                     """
                    ),
            
            Question(question: [
                "Какую последовательность мы получим в консоль?"
            ],
                     image: "Multithreading06",
                     optionA: "Всегда разную",
                     optionB: "2 -> 1",
                     optionC: "1 -> 2",
                     optionD: "",
                     id: 563811011,
                     links: [
                        "https://habr.com/ru/articles/320152/",
                        "https://developer.apple.com/documentation/DISPATCH"
                     ],
                     helpText: """
                     Всегда разную. Здесь мы создаем кастомную параллельную очередь.
                     
                     Обе асинхронные задачи выполняются параллельно, и мы не можем прогнозировать скорость их выполнения и очередность.
                     """
                    ),
            
            Question(question: [
                "Выберите корректную последовательность вывода"
            ],
                     image: "Multithreading07",
                     optionA: "1 -> 2 -> 3",
                     optionB: "1 -> 3 -> 2",
                     optionC: "3 -> 2 -> 1",
                     optionD: "",
                     id: 224297725,
                     links: [
                        "https://habr.com/ru/articles/320152/",
                        "https://developer.apple.com/documentation/DISPATCH"
                     ],
                     helpText: """
                     1 -> 2 -> 3. В этом примере мы создаем последовательную очередь, и все задачи выполняются по очереди, одна за другой.
                     """
                    ),
            
            Question(question: [
                "Выберите корректную последовательность вывода в консоль"
            ],
                     image: "Multithreading08",
                     optionA: "1 -> 2",
                     optionB: "2 -> 1",
                     optionC: "Будет разная",
                     optionD: "",
                     id: 988978955,
                     links: [
                        "https://habr.com/ru/articles/320152/",
                        "https://developer.apple.com/documentation/DISPATCH"
                     ],
                     helpText: """
                     1 -> 2. Задача, добавленная в глобальную очередь с использованием sync, будет выполнена синхронно, ожидая завершения перед продолжением выполнения следующей инструкции.
                     """
                    ),
            
            Question(question: [
                "Что мы получим в консоль?"
            ],
                     image: "Multithreading09",
                     optionA: "1 -> 2 -> 3",
                     optionB: "1 -> 3 -> 2",
                     optionC: "Получим ошибку",
                     optionD: "",
                     id: 398531874,
                     links: [
                        "https://habr.com/ru/articles/320152/",
                        "https://developer.apple.com/documentation/DISPATCH"
                     ],
                     helpText: """
                     1 -> 2 -> 3. Задача, добавленная в глобальную очередь с использованием sync, будет выполнена синхронно, ожидая завершения перед продолжением выполнения следующей инструкции.
                     """
                    ),
            
            Question(question: [
                "Что мы получим в консоль?"
            ],
                     image: "Multithreading10",
                     optionA: "Столкнемся с ошибкой",
                     optionB: "1 -> 2 -> 3",
                     optionC: "1 -> 3 -> 2",
                     optionD: "",
                     id: 289624181,
                     links: [
                        "https://habr.com/ru/articles/320152/",
                        "https://developer.apple.com/documentation/DISPATCH"
                     ],
                     helpText: """
                     Столкнемся с ошибкой. В данном случае у нас получается deadlock.
                     
                     print(1) выполняется на главном потоке, и "1" будет выведено в консоль.
                     
                     DispatchQueue.main.sync { print(2) } это синхронное выполнение на главной очереди. Это означает, что выполнение этого замыкания будет заблокировано до тех пор, пока замыкание не завершится.
                     
                     print(3) никогда не будет выполнен из-за блокировки в предыдущем шаге. Чтобы избежать блокировки, стоит избегать вызовов sync на том потоке, на котором они уже выполняются.
                     """
                    ),
            
            Question(question: [
                "Какая последовательность символов будет в консоли?"
            ],
                     image: "Multithreading11",
                     optionA: "a -> d -> c -> b",
                     optionB: "a -> b -> c -> d",
                     optionC: "a -> c -> b -> d",
                     optionD: "",
                     id: 396755982,
                     links: [
                        "https://habr.com/ru/articles/320152/",
                        "https://developer.apple.com/documentation/DISPATCH"
                     ],
                     helpText: """
                     a -> d -> c -> b. Сначала выполняются самые первые поставленные в главную очередь задачи (a / d).
                     
                     После этого выполняется первая асинхронно добавленная задача (c).
                     
                     И в последнюю очередь выполнится вторая асинхронно добавленная задача (d).
                     """
                    ),
            
            Question(question: [
                "Что выведется в консоль?"
            ],
                     image: "Multithreading12",
                     optionA: "a -> d",
                     optionB: "a -> d -> c",
                     optionC: "Ничего",
                     optionD: "",
                     id: 967005329,
                     links: [
                        "https://habr.com/ru/articles/320152/",
                        "https://developer.apple.com/documentation/DISPATCH"
                     ],
                     helpText: """
                     a -> d. Сначала выведется "a", следом - "d". Так как это самые первые задачи главной очереди, и на них ничего не влияет.
                     
                     После чего мы перейдем к выполнению асинхронно добавленной задачи, внутри которой случится взаимная блокировка, так как мы пытаемся на этот же поток добавить синхронную задачу.
                     
                     Синхронная задача будет ждать завершения асинхронной, а поток будет ждать выполнения синхронной задачи.
                     
                     То есть поток заблокируется, и попытка вывести на нем дальше хоть что-нибудь - не даст никакого результата.
                     """
                    ),
            
            Question(question: [
                "Что мы получим в консоль после запуска?"
            ],
                     image: "Interview02",
                     optionA: "[0, 1] [0]",
                     optionB: "[0] [0, 1]",
                     optionC: "[0, 1] [0, 1]",
                     optionD: "",
                     id: 589724513,
                     links: [
                        "https://habr.com/ru/articles/673372/",
                        "https://ios-interview.ru/copy-on-write/"
                     ],
                     helpText: """
                     [0, 1] [0]. В первых двух строках мы инициализировали массив а (value type), содержащий значение 0, и присвоили массиву б значение массива а.
                     
                     В этот момент они ссылаются на одну область в памяти. Фактического копирования не происходит (по причине copy-on-write).
                     
                     Когда мы добавляем элемент (изменяем массив), предварительно просходит реальное копирование (выделение копии в другую область памяти). То есть в массив б попадает исходный массив [0].
                     
                     Поэтому когда мы выводим значения на консоль, мы видим измененный массив а = [0, 1], и изначальную копию в массиве б = [0].
                     """
                    ),
            
            Question(question: [
                "Что мы получим в консоль после запуска?"
            ],
                     image: "Interview04",
                     optionA: "4",
                     optionB: "3",
                     optionC: "2, 1, 2",
                     optionD: "",
                     id: 426431682,
                     links: [
                        "https://habr.com/ru/articles/440722/",
                        "https://developer.apple.com/documentation/swift/array/map(_:)-87c4d"
                     ],
                     helpText: """
                     4. Здесь мы используем map для преобразования каждого элемента массива matrix.
                     
                     Однако, в данном случае, map не делает ничего с содержимым массивов, а просто создает новый массив, в котором элементы остаются теми же самыми.
                     
                     Поэтому результат будет равен количеству элементов в исходном массиве matrix, включая nil.
                     """
                    ),
            
            Question(question: [
                "Что мы получим в консоль?"
            ],
                     image: "Interview05",
                     optionA: "3",
                     optionB: "6",
                     optionC: "4",
                     optionD: "",
                     id: 120669069,
                     links: [
                        "https://habr.com/ru/articles/440722/",
                        "https://developer.apple.com/documentation/swift/sequence/compactmap(_:)"
                     ],
                     helpText: """
                     3. Здесь мы используем compactMap, который удаляет nil из основного массива массивов.
                     
                     Результатом работы этого метода будет:
                     [
                        [Optional(1), Optional(2)],
                        [Optional(3), nil],
                        [Optional(4), Optional(5)]
                     ]
                     
                     Таким образом, будет создан новый массив, в котором будут только ненулевые элементы из массива matrix, и результатом .count будет 3.
                     """
                    ),
            
            Question(question: [
                "Что мы получим в консоль?"
            ],
                     image: "Interview06",
                     optionA: "6",
                     optionB: "0",
                     optionC: "5",
                     optionD: "",
                     id: 812154408,
                     links: [
                        "https://habr.com/ru/articles/440722/",
                        "https://developer.apple.com/documentation/swift/sequence/compactmap(_:)"
                     ],
                     helpText: """
                     6. Здесь мы используем compactMap, который удаляет nil из основного массива массивов
                     
                     Результатом работы этого метода будет:
                     [
                        [Optional(1), Optional(2)],
                        [Optional(3), nil],
                        [Optional(4), Optional(5)]
                     ]
                     
                     После чего используем flatMap, который "разворачивает" массив массивов в один плоский массив. В данном случае, это приводит к созданию массива [Optional(1), Optional(2), Optional(3), nil, Optional(4), Optional(5)], результатом .count которого, будет шесть. 
                     """
                    ),
            
            Question(question: [
                "Какой QoS в DispatchQueue выше по приоритету?"
            ],
                     image: "",
                     optionA: "User Interactive",
                     optionB: "User Initiated",
                     optionC: "",
                     optionD: "",
                     id: 726432007,
                     links: [
                        "https://habr.com/ru/articles/572316/",
                        "https://habr.com/ru/articles/578752/",
                        "https://ios-interview.ru/top-20-middle-ios-interview-questions"
                     ],
                     helpText: """
                     User Interactive. QualityofService или QoS — качество обслуживания, которое появилось с приходом iOS 8. QoS помогает выставить приоритет, с которым будет выполняться наша задача DispatchQueue, QoS используется с функцией .async().
                     
                     User Interactive — используется для взаимодействия с пользователем. Это может быть любая работа, которая проходит в главном потоке, например, анимация или обновление интерфейса.
                     
                     User Initiated — используется при инициации работы пользователем. Это может быть такая задача как загрузка данных по API. Работа должна быть завершена, чтобы пользователь мог продолжить пользоваться приложением.
                     
                     User Interactive имеет самый высокий приоритет и будет выполняться в первую очередь.
                     """
                    ),
            
            Question(question: [
                "Какой результат мы получим в консоль?"
            ],
                     image: "Interview07",
                     optionA: "11",
                     optionB: "12",
                     optionC: "5",
                     optionD: "",
                     id: 629855876,
                     links: [
                        "https://developer.apple.com/documentation/swift/array/reduce(_:_:)",
                        "https://developer.apple.com/documentation/swift/set"
                     ],
                     helpText: """
                     11. Множество исключает из себя повторяющиеся значения, поэтому у нас останется только одна еденица.
                     
                     Функциональная команда .reduce возьмет каждый элемент, и прибавит его к исходному значению, начинающемуся с 0. Сумма всех чисел будет 11.
                     """
                    ),
            
            Question(question: [
                "Какой результат мы получим в консоль?"
            ],
                     image: "Interview11",
                     optionA: "1110",
                     optionB: "1111",
                     optionC: "2210",
                     optionD: "",
                     id: 748035143,
                     links: [
                        "https://swiftbook.org/docs/1509/"
                     ],
                     helpText: """
                     1110. У вас есть опция определять один или оба наблюдателя свойства:

                     willSet - вызывается прямо перед сохранением значения
                     didSet - вызывается сразу после сохранения значения
                     
                     В нашем случае мы установим исходное значение 1000 (наблюдатели свойств не вызываются), после чего, когда мы вызовем foo.bar += 10, мы попадем в willSet, где у нас есть доступ только к новому значению (1010), но нет возможности изменить его.
                     
                     После чего мы попадаем в блок didSet, где наше значение прибавляется на 10 (исходный вызов), а потом мы прибавляем к уже установленному свойству еще +100 (так как оно уже доступно для изменений).
                     """
                    ),
            
            Question(question: [
                "В каком самом раннем методе жизненного цикла View Controller известны корректные размеры всех его subviews?"
            ],
                     image: "",
                     optionA: "viewDidLayoutSubviews",
                     optionB: "viewWillLayoutSubviews",
                     optionC: "viewWillAppear",
                     optionD: "",
                     id: 957679865,
                     links: [
                        "https://habr.com/ru/articles/654517/",
                        "https://sparrowcode.io/ru/tutorials/uiviewcontroller-lifecycle"
                     ],
                     helpText: """
                     viewDidLayoutSubviews. Самый ранний метод жизненного цикла вью контроллера, в котором известны корректные размеры всех его сабвью, является метод viewDidLayoutSubviews.
                     
                     Этот метод вызывается после того, как система установила фактические размеры всех представлений в иерархии вью контроллера.
                     
                     Когда вызывается viewDidLayoutSubviews, размеры всех подпредставлений уже были правильно установлены в соответствии с геометрией и оформлением вью контроллера.

                     Таким образом, viewDidLayoutSubviews представляет собой хорошую точку входа для настройки и настройки размещения сабвью перед их отображением на экране.
                     """
                    ),
            
            Question(question: [
                "Как узнать загружена ли view у View Controller?"
            ],
                     image: "",
                     optionA: "Проверить isViewLoaded",
                     optionB: "Внутри loadView()",
                     optionC: "Никак",
                     optionD: "",
                     id: 422405871,
                     links: [
                        "https://habr.com/ru/articles/654517/",
                        "https://sparrowcode.io/ru/tutorials/uiviewcontroller-lifecycle"
                     ],
                     helpText: """
                     Проверить isViewLoaded. Для того чтобы узнать, загружена ли вью во вью контроллере, можно использовать свойство `isViewLoaded`.

                     Например:
                     
                     if isViewLoaded {
                         // Вью загружена
                     } else {
                         // Вью еще не загружена
                     }

                     Вы можете проверить это свойство внутри методов жизненного цикла вью контроллера или в других методах, где вам может понадобиться узнать, загружена ли вью.
                     """
                    ),
            
            Question(question: [
                "Скомпилируется ли данный код?"
            ],
                     image: "Interview15",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 535821316,
                     links: [
                        "https://swiftbook.org/docs/1510/",
                        "https://swiftbook.org/docs/1509/"
                     ],
                     helpText: """
                     Нет. Этот код не соберется. Компилятор укажет на ошибку: Value type 'AA' cannot have a stored property that recursively contains it
                     
                     Ошибка возникает по причине того, что типы значений занимают фиксированное место в памяти. Это пространство предопределено типом и должно быть известно во время компиляции.
                     
                     Таким образом, компилятору нужно знать, сколько места зарезервировать для структуры АА и BB.
                     
                     Но значение вычислить невозможно так как одна структура содержит, в том числе, другое значение того же типа, а это значение содержит третье, и так далее, что приводит к рекурсии.
                     """
                    ),
        ]
    }
}
