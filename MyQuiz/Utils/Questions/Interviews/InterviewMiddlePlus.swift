//
//  InterviewMiddlePlus.swift
//  Swifty-Quiz
//
//  Created by Евгений Никитин on 03.10.2023.
//  Copyright © 2023 Evel-Devel. All rights reserved.
//

import Foundation

final class InterviewMiddlePlus {
    static func getQuestions() -> [Question] {
        return [
            Question(question: [
                "Когда происходит автоматическая расстановка retain / release в ARC?"
            ],
                     image: "",
                     optionA: "На этапе компиляции",
                     optionB: "В райнтайме",
                     optionC: "",
                     optionD: "",
                     id: 504040212,
                     links: [
                        "https://habr.com/ru/articles/592385/"
                     ],
                     helpText: """
                     На этапе компиляции. ARC отличается от MRC тем, что компилятор сам расставляет методы retain/release за программиста. Важно понимать, что ARC работает при компиляции, а подсчет ссылок — в рантайме.
                     """
                    ),
            
            Question(question: [
                "В какой момент происходит подсчет ссылок в ARC?"
            ],
                     image: "",
                     optionA: "В райнтайме",
                     optionB: "На этапе компиляции",
                     optionC: "В дебаг режиме",
                     optionD: "",
                     id: 595096940,
                     links: [
                        "https://habr.com/ru/articles/592385/"
                     ],
                     helpText: """
                     В рантайме. ARC отличается от MRC тем, что компилятор сам расставляет методы retain/release за программиста. Важно понимать, что ARC работает при компиляции, а подсчет ссылок — уже в рантайме.
                     """
                    ),
            
            Question(question: [
                "Выберите objc обертку для работы с потоками в Swift?"
            ],
                     image: "",
                     optionA: "Thread",
                     optionB: "Operation",
                     optionC: "",
                     optionD: "",
                     id: 624591904,
                     links: [
                        "https://habr.com/ru/post/320152/",
                        "https://habr.com/ru/post/572316/"
                     ],
                     helpText: """
                     Thread. В iOS программировании многопоточность предоставляется в виде нескольких инструментов:
                     - Thread
                     - Grand Central Dispatch (GCD)
                     - Operation.

                     Thread — это objc обертка над pthread, которая предоставляет более удобный способ взаимодействия с потоком, а Operation - объектно-ориентированное API, построенное поверх GCD.
                     """
                    ),

            Question(question: [
                "Выберите объектно-ориентированное API для работы с многопоточностью, построенное поверх GCD в Swift?"
            ],
                     image: "",
                     optionA: "Operation",
                     optionB: "Grand Central Dispatch",
                     optionC: "Thread",
                     optionD: "",
                     id: 260560281,
                     links: [
                        "https://habr.com/ru/post/320152/"
                     ],
                     helpText: """
                     Operation. В iOS программировании многопоточность предоставляется в виде нескольких инструментов:
                     - Thread
                     - Grand Central Dispatch (GCD)
                     - Operation.

                     Thread это низкоуровневый механизм, а Operation - объектно-ориентированное API, построенное поверх GCD.
                     """
                    ),
            
            Question(question: [
                "Какой вывод мы получим в консоль?"
            ],
                     image: "Multithreading15",
                     optionA: "1, 1",
                     optionB: "1, 2",
                     optionC: "2, 2",
                     optionD: "",
                     id: 424981586,
                     links: [
                        "https://habr.com/ru/articles/572316/",
                        "https://habr.com/ru/articles/578752/",
                        "https://ios-interview.ru/multithreading-problems/"
                     ],
                     helpText: """
                     1, 1. C помощью первого print() мы выводим первую единицу, а потом, так как вызов функции изменения значения происходит асинхронно - поток практически моментально выполняет вторую команду print() (не ожидая), и мы получаем вторую 1, до ее изменения.
                     
                     Данная проблема в многопоточности называется Race condition. Состояние гонки — ситуация, возникающая, когда время или порядок событий влияют на корректность результата.
                     """),
            
            Question(question: [
                "Какой вывод мы получим в консоль?"
            ],
                     image: "Multithreading16",
                     optionA: "1, 2",
                     optionB: "1, 1",
                     optionC: "2, 2",
                     optionD: "",
                     id: 774472138,
                     links: [
                        "https://habr.com/ru/articles/572316/",
                        "https://habr.com/ru/articles/578752/",
                        "https://ios-interview.ru/multithreading-problems/"
                     ],
                     helpText: """
                     1, 2. C помощью первого print() мы выводим первую единицу, а потом, так как вызов функции изменения значения происходит синхронно, и поток блокируется до выполнения функции изменения значения, мы получаем 2.
                     
                     Данный подход, с синхронным вызовом, позволяет решать проблему многопоточности,  называемую Race condition.
                     
                     С помощью метода sync мы избавились от состояния гонки. Но это не значит, что его нужно использовать всегда, ведь он блокирует главный поток и ожидание может быть больше 1 секунды, как в нашем примере.
                     """),
            
            Question(question: [
                "Какой результат будет выведен в консоль?"
            ],
                     image: "Multithreading17",
                     optionA: "Всегда разный, < 2000",
                     optionB: "2000",
                     optionC: "Получим ошибку",
                     optionD: "",
                     id: 603825870,
                     links: [
                        "https://habr.com/ru/articles/572316/",
                        "https://habr.com/ru/articles/578752/",
                        "https://ios-interview.ru/multithreading-problems/"
                     ],
                     helpText: """
                     Всегда разный, < 2000. Мы ожидаем результат count = 2000. Но, к сожалению, результат будет всегда меньше этого числа, эта проблема называется Data Race (Гонка за данными).
                     
                     Это происходит потому, что операция увеличения счетчика не атомарна — она состоит из нескольких шагов:
                     - Чтение уже хранящегося значения;
                     - Сложение результата с единицей;
                     - Запись конечного результата обратно в переменную.
                     
                     Так как в нашем примере отсутствует какая-либо синхронизация, то наши потоки могут оказаться в одной точке, например, в которой считывается текущее значение переменной (оба потока одновременно прочитали текущее значение 0, и присвоив единицу записали в результат 1).
                     """
                    ),
            
            Question(question: [
                "Кто отлавливает все системные события и запускает их обработку (например: тап по экрану телефона)?"
            ],
                     image: "",
                     optionA: "RunLoop",
                     optionB: "Main Thread",
                     optionC: "Hit Test",
                     optionD: "",
                     id: 834326232,
                     links: [
                        "https://habr.com/ru/articles/572316/",
                        "https://habr.com/ru/company/otus/blog/590319/"
                     ],
                     helpText: """
                     RunLoop. Ранлуп главного потока отлавливает все системные события и запускает их обработку на главном потоке, будь то нажатия на клавиши клавиатуры, если это macOS, или тап по экрану iOS устройства.
                     
                     Также RunLoop умеет управлять своим потоком: будить для выполнения некоторой работы и переводить в спячку после ее выполнения.
                     """
                    ),
            
            Question(question: [
                "Где будет хранится экземпляр value type, если он является частью экземпляра reference type?"
            ],
                     image: "",
                     optionA: "Куча (heap)",
                     optionB: "Стек (stack)",
                     optionC: "",
                     optionD: "",
                     id: 273577575,
                     links: [
                        "https://ios-interview.ru/value-and-reference-type/"
                     ],
                     helpText: """
                     Куча (heap). Существует одно важное замечание — если экземпляр типа значения является частью экземпляра ссылочного типа, то значение сохраняется в куче вместе с экземпляром ссылочного типа.
                     
                     Например, структура сама по себе хранится в стеке, но если эта структура расположена в классе, то так как класс хранится в куче, то и структура будет сохранена в куче.
                     """
                    ),
            
            Question(question: [
                "При наличии относительно небольшого объема данных, поиск быстрее выполнится по какой коллекции?"
            ],
                     image: "",
                     optionA: "Dictionary",
                     optionB: "Array",
                     optionC: "Одинаково",
                     optionD: "",
                     id: 146904343,
                     links: [
                        "https://swiftbook.ru/content/languageguide/collection-types/",
                        "https://habr.com/ru/sandbox/173690/"
                     ],
                     helpText: """
                     Dictionary. При поиске элемента на позиции 99_999 в коллекции из 100 тысяч элементов, поиск по множеству (Set) займет ~9 микросекунд, поиск по словарю займет ~50 микросекунд, поиск по массиву займет ~5000 микросекунд.
                     
                     Поиск по словарю происходит намного быстрее, чем поиск по массиву, потому что словарь использует хэш-таблицу для организации данных.

                     В хэш-таблице элементы хранятся в виде пар "ключ-значение". При поиске элемента по ключу, словарь использует хэш-функцию, которая преобразует ключ в определенное числовое значение (хэш).
                     
                     Затем по этому хэшу можно быстро найти соответствующее значение. В худшем случае, словарь имеет постоянное время выполнения для операции поиска, равное O(1), то есть время поиска не зависит от размера данных.

                     С другой стороны, при поиске в массиве, программе приходится последовательно просматривать каждый элемент, чтобы найти нужный.
                     """
                    ),
            
            Question(question: [
                "По какому типу коллекции, содержащей 100 тысяч элементов, поиск произойдет быстрее?"
            ],
                     image: "",
                     optionA: "Set",
                     optionB: "Array",
                     optionC: "Одинаковое время",
                     optionD: "",
                     id: 504720461,
                     links: [
                        "https://swiftbook.ru/content/languageguide/collection-types/",
                        "https://habr.com/ru/sandbox/173690/"
                     ],
                     helpText: """
                     Set. При поиске элемента на позиции 99_999 в коллекции из 100 тысяч элементов, поиск по множеству (Set) займет ~9 микросекунд, поиск по словарю займет ~50 микросекунд, поиск по массиву займет ~5000 микросекунд.
                     
                     Поиск по множеству происходит быстрее из-за хэшируемых значений.
                     
                     Это работает следующим образом: каждый элемент вставляется в определенное место в хэш-таблице с учетом хэш-кода элемента. При поиске элемента в хэш-таблице, система вычисляет хэш-код и сразу переходит к соответствующей ячейке. Это позволяет значительно ускорить процесс поиска.
                     
                     Так же в отличии от словаря, в множестве нет пар "ключ-значение", а элементы внутри коллекции - уникальные, это тоже влияет на результаты поисковой задачи.
                     """
                    ),
            
            Question(question: [
                "Для какой категории типов в Swift реализован механизм COW (copy-on-write)?"
            ],
                     image: "",
                     optionA: "Value type",
                     optionB: "Reference type",
                     optionC: "",
                     optionD: "",
                     id: 851838094,
                     links: [
                        "https://habr.com/ru/articles/673372/",
                        "https://ios-interview.ru/copy-on-write/"
                     ],
                     helpText: """
                     Value type. Данный механизм позволяет при передаче типов значений не копировать их до первого изменения, избавляя приложение от лишних копирований, улучшая производительность.
                     """
                    ),
            
            Question(question: [
                "Выберите тип данных в Swift, у которого реализован механизм copy-on-write"
            ],
                     image: "",
                     optionA: "Array",
                     optionB: "Int",
                     optionC: "Bool",
                     optionD: "",
                     id: 686203447,
                     links: [
                        "https://habr.com/ru/articles/673372/",
                        "https://ios-interview.ru/copy-on-write/"
                     ],
                     helpText: """
                     Array. Когда массив копируется, он использует механизм copy-on-write, чтобы избежать фактического копирования элементов до тех пор, пока какой-либо из них не изменится.
                     """
                    ),
            
            Question(question: [
                "Выберите тип данных в Swift, у которого реализован механизм copy-on-write"
            ],
                     image: "",
                     optionA: "String",
                     optionB: "Double",
                     optionC: "",
                     optionD: "",
                     id: 605763565,
                     links: [
                        "https://habr.com/ru/articles/673372/",
                        "https://ios-interview.ru/copy-on-write/"
                     ],
                     helpText: """
                     String. Строки в Swift представляют собой коллекцию символов, и их реализация основана на структуре, которая по своей природе поддерживает copy-on-write.
                     
                     Когда создается копия строки, на самом деле копируется ссылка на буфер с данными (массив байтов, представляющих символы строки), а не сам буфер с данными. Это позволяет сэкономить память и ресурсы, поскольку копирование всего буфера данных может быть дорого и неэффективно.

                     Когда какая-либо из копий строки изменяется (например, при добавлении символа или изменении символа), тогда происходит реальное копирование буфера данных, чтобы не затронуть другие копии. Это обеспечивает эффективное использование памяти и быструю работу с общими данными.
                     """
                    ),
            
            Question(question: [
                "Какой порядок цифр чаще всего будет выведен в консоль?"
            ],
                     image: "Multithreading18",
                     optionA: "1, 2, 6, 7, 3, 4, 5",
                     optionB: "1, 2, 6, 3, 5, 4, 7",
                     optionC: "1, 2, 6, 3, 4, 5, 7",
                     optionD: "",
                     id: 944403785,
                     links: [
                        "https://habr.com/ru/articles/572316/",
                        "https://habr.com/ru/articles/578752/",
                        "https://ios-interview.ru/top-20-middle-ios-interview-questions"
                     ],
                     helpText: """
                     1, 2, 6, 3, 7, 4, 5. Указатель доходит до print («1») и печатает результат. Далее вызываем функцию в главном потоке, печатаем print(«2»). Далее отправлям все вложенные вызовы асинхронно в глобальную очередь, она приступит к выполнению после завершения работ на главном потоке.
                     
                     Следующая команда print («6»). После - выходим из функции и продолжаем выполнять код на главном потоке — print («7»). После главного потока, наступает очередь глобальной очереди — print («3»).
                     
                     Далее выполняется print («4»), поскольку он вызывается синхронно. Потом, в последнюю очередь - print («5»).
                     
                     Обратите внимание на следующий момент: если запустить код несколько раз, то результат может отличаться друг от друга — вывод 7 и 3 может меняться местами, если у системы есть свободные ресурсы, то асинхронный поток может начать выполняться быстрее, чем мы дойдем до семерки.
                     """
                    ),
            
            Question(question: [
                "Скомпилируется ли данный код?"
            ],
                     image: "Interview08",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 142461121,
                     links: [
                        "https://swiftbook.ru/content/languageguide/properties/",
                        "https://ios-interview.ru/top-20-middle-ios-interview-questions"
                     ],
                     helpText: """
                     Нет. В нашем случае код не скомпилируется.
                     
                     Все дело в ключевых словах class и static. Помечая функцию как class — вы позволяете переопределять методы в классах наследниках, static — не позволяет переопределять классы.
                     
                     Это главное отличие при использовании методов.
                     """
                    ),
            
            Question(question: [
                "Что мы получим в консоль?"
            ],
                     image: "Interview09",
                     optionA: "1",
                     optionB: "0",
                     optionC: "",
                     optionD: "",
                     id: 890776955,
                     links: [
                        "https://swiftbook.ru/content/language-reference/statements/",
                        "https://ios-interview.ru/top-20-middle-ios-interview-questions"
                     ],
                     helpText: """
                     1. Это особенность оператора defer.
                     
                     Оператор выполняет код непосредственно перед тем, как функция, в которой расположен оператор, выйдет за пределы области видимости программы.
                     
                     Поэтому в нашем примере index обновит свое значение уже после того, как сработает оператор return.
                     """
                    ),
            
            Question(question: [
                "Что мы получим в консоль?"
            ],
                     image: "Interview10",
                     optionA: "2",
                     optionB: "1",
                     optionC: "3",
                     optionD: "",
                     id: 890776955,
                     links: [
                        "https://swiftbook.ru/content/language-reference/statements/",
                        "https://ios-interview.ru/top-20-middle-ios-interview-questions"
                     ],
                     helpText: """
                     2. Это особенность оператора defer.
                     
                     Оператор выполняет код непосредственно перед тем, как функция, в которой расположен оператор, выйдет за пределы области видимости программы.
                     
                     Поэтому в нашем примере index обновит свое значение уже после того, как сработает оператор return.
                     """
                    ),
            
            Question(question: [
                "Выберите самый быстрый тип диспетчеризации в Swift"
            ],
                     image: "",
                     optionA: "Direct Dispatch",
                     optionB: "Table Dispatch",
                     optionC: "Message Dispatch",
                     optionD: "",
                     id: 938199377,
                     links: [
                        "https://habr.com/ru/articles/714830/",
                        "https://ios-interview.ru/top-20-middle-ios-interview-questions"
                     ],
                     helpText: """
                     Direct Dispatch. Direct Dispatch (Статическая диспетчеризация) - самый быстрый тип диспетчеризации.
                     
                     Адрес вызываемой функции определяется во время компиляции, поэтому затраты на такие вызовы минимальны.
                     
                     Для использования статической диспетчеризации вы можете пометить методы ключевым словом private или классы ключевым словом final.
                     """
                    ),
            
            Question(question: [
                "Какой тип диспетчеризации в Swift является динамическим?"
            ],
                     image: "",
                     optionA: "Table Dispatch",
                     optionB: "Direct Dispatch",
                     optionC: "",
                     optionD: "",
                     id: 938199377,
                     links: [
                        "https://habr.com/ru/articles/714830/",
                        "https://ios-interview.ru/top-20-middle-ios-interview-questions"
                     ],
                     helpText: """
                     Table Dispatch. Table Dispatch (Динамическая диспетчеризация) — распространенный тип. Адрес вызываемой функции определяется во время выполнения. У каждого подкласса есть собственная таблица с указателем на функцию для каждого метода.
                     
                     По мере того как подклассы добавляют к классу новые методы, эти методы добавляются в конец этой таблицы. Затем к таблице обращаются во время выполнения, чтобы определить метод для выполнения. Это и есть динамическая диспетчеризация.
                     
                     В Swift данный подтип делится на два подтипа:
                     Virtual Table — используется при наследовании классов, что приносит дополнительные затраты.
                     Witness Table — используется для реализации протоколов, наследование отсутствует.
                     """
                    ),
            
            Question(question: [
                "Скомпилируется ли данный код?"
            ],
                     image: "Interview12",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     id: 519480210,
                     links: [
                        "https://medium.com/@leandromperez/bidirectional-associations-using-value-types-in-swift-548840734047",
                        
                     ],
                     helpText: """
                     Нет. Структура не может иметь хранимое свойство, которое рекурсивно содержит саму структуру.
                     
                     Мы получим ошибку "Value type 'Box' cannot have a stored property that recursively contains it"
                     """
                    ),
            
            Question(question: [
                "Что мы получим в консоль?"
            ],
                     image: "Interview13",
                     optionA: "meow, meow",
                     optionB: "meow, say",
                     optionC: "say, say",
                     optionD: "",
                     id: 783004301,
                     links: [
                        "https://swiftbook.org/docs/1496/"
                     ],
                     helpText: """
                     meow, meow. Оба вызова выведут meow, поскольку класс Cat переопределяет внутри себя метод say, так что приведение к протоколу не меняет вывод в консоль.
                     
                     В случае, если бы дефолтную реализацию метода в расширении протокола не переопределяли в классе, мы бы получили say, say.
                     """
                    ),
            
            Question(question: [
                "Что мы получим в консоль?"
            ],
                     image: "Interview14",
                     optionA: "say, say",
                     optionB: "meow, say",
                     optionC: "meow, meow",
                     optionD: "",
                     id: 955826323,
                     links: [
                        "https://swiftbook.org/docs/1496/"
                     ],
                     helpText: """
                     say, say. В данном случае, мы не переопределяли в классе дефолтную реализацию метода, которая написана в расширении протокола, поэтому мы получаем в консоль say, say.
                     """
                    ),
        ]
    }
}
